#!/usr/bin/env bash
# -*- coding: utf-8 -*-
# shellcheck shell=bash disable=SC1091,SC2039,SC2166
#
#  chili-update-grub-btrfs
#  Gera entradas GRUB para todos Btrfs detectados e EFI
#  Created: 2025/09/29 - 19:48
#  Altered: 2025/09/29 - 19:48
#  Updated: seg 29 set 2025 23:54:11 -03
#
#  Copyright (c) 2025-2025, Vilmar Catafesta <vcatafesta@gmail.com>
#  All rights reserved.
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions
#  are met:
#  1. Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
#  THIS SOFTWARE IS PROVIDED BY Vilmar Catafesta ''AS IS'' AND ANY EXPRESS OR
#  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
#  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
#  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
#  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
#  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
##############################################################################
#export LANGUAGE=pt_BR
export TEXTDOMAINDIR=/usr/share/locale
export TEXTDOMAIN=chili-update-grub-btrfs

#debug
export PS4='${red}${0##*/}${green}[$FUNCNAME]${pink}[$LINENO]${reset}'
#set -x
set -e
shopt -s extglob

#system
declare APP="${0##*/}"
declare _VERSION_="1.9.29-20250929"
declare APPDESC="$APP - Gera entradas GRUB para todos Btrfs detectados e EFI"
declare distro="$(uname -n)"
declare DEPENDENCIES=(tput lsblk blkid sed update-grub cut)

MostraErro() { echo "erro: ${red}$1${reset} => comando: ${cyan}'$2'${reset} => result=${yellow}$3${reset}";}
trap 'MostraErro "$APP[$FUNCNAME][$LINENO]" "$BASH_COMMAND" "$?"; exit 1' ERR

set_varcolors() {
  # does the terminal support true-color?
  if [[ -n "$(command -v "tput")" ]]; then
    #tput setaf 127 | cat -v  #capturar saida
    : "${RED=$(tput bold)$(tput setaf 196)}"
    : "${GREEN=$(tput bold)$(tput setaf 2)}"
    : "${YELLOW=$(tput bold)$(tput setaf 3)}"
    : "${BLUE=$(tput setaf 4)}"
    : "${PURPLE=$(tput setaf 125)}"
    : "${CYAN=$(tput setaf 6)}"
    : "${NC=$(tput sgr0)}"
    : "${RESET=$(tput sgr0)}"
    : "${BOLD=$(tput bold)}"
    : "${black=$(tput bold)$(tput setaf 0)}"
    : "${reverse=$(tput rev)}"
    : "${branca=${black}$(tput setab 7)}"

    : "${reset=$(tput sgr0)}"
    : "${rst=$(tput sgr0)}"
    : "${bold=$(tput bold)}"
    : "${underline=$(tput smul)}"
    : "${nounderline=$(tput rmul)}"
    : "${reverse=$(tput rev)}"

    : "${black=$(tput bold)$(tput setaf 0)}"
    : "${red=$(tput bold)$(tput setaf 196)}"
    : "${green=$(tput bold)$(tput setaf 2)}"
    : "${yellow=$(tput bold)$(tput setaf 3)}"
    : "${blue=$(tput setaf 27)}"
    : "${pink=$(tput setaf 5)}"
    : "${magenta=$(tput setaf 5)}"
    : "${cyan=$(tput setaf 6)}"
    : "${white=$(tput setaf 7)}"
    : "${gray=$(tput setaf 8)}"
    : "${light_red=$(tput setaf 9)}"
    : "${light_green=$(tput setaf 10)}"
    : "${light_yellow=$(tput setaf 11)}"
    : "${light_blue=$(tput setaf 12)}"
    : "${light_magenta=$(tput setaf 13)}"
    : "${light_cyan=$(tput setaf 14)}"
    : "${light_white=$(tput setaf 15)}"
    : "${orange=$(tput setaf 202)}"
    : "${purple=$(tput setaf 125)}"
    : "${violet=$(tput setaf 61)}"

    # Definir cores de fundo
    : "${preto=$(tput setab 0)}"
    : "${vermelho=$(tput setab 196)}"
    : "${verde=$(tput setab 2)}"
    : "${amarelo=$(tput setab 3)}"
    : "${azul=$(tput setab 20)}"
    : "${roxo=$(tput setab 5)}"
    : "${ciano=$(tput setab 6)}"
    : "${branca="${black}$(tput setab 7)"}"
    : "${cinza=$(tput setab 8)}"
    : "${laranja=$(tput setab 202)}"
    : "${roxa=$(tput setab 125)}"
    : "${violeta=$(tput setab 61)}"

    : "${COL_NC='\e[0m'}" # No Color
    : "${COL_LIGHT_GREEN='\e[1;32m'}"
    : "${COL_LIGHT_RED='\e[1;31m'}"
    : "${DONE="${COL_LIGHT_GREEN} done!${COL_NC}"}"
    : "${OVER="\\r\\033[K"}"
    : "${DOTPREFIX="  ${black}::${reset} "}"
    : "${TICK="${white}[${green}✓✓${rst}${white}]${rst}"}"
    : "${CROSS="${white}[${red}✗✗${rst}${white}]${rst}"}"
#   : "${INFO="${white}[${yellow}ii${rst}${white}]${rst}"}"
#   : "${INFO="${white}[${yellow}II${rst}${white}]${rst}"}"
#   : "${INFO="${white}[${yellow}ⓘ ${rst}${white}]${rst}"}"
    : "${INFO="${white}[${yellow}➡ ${rst}${white}]${rst}"}"

    # dialog colors
    REVERSE="\Zr"
    UNDERLINE="\Zu"
    BOLD="\Zb"
    RESET="\Zn"
    BLACK="\Z0"
    YELLOW="\Z3"
    AMARELO="\Zb\Z3"
    WHITE="\Z7"
    BLUE="\Z4"
    AZUL="\Zb\Z4"
    CYAN="\Z6"
    RED="\Z1"
    GREEN="\Z2"
    MAGENTA="\Z5"
  else
    unset_varcolors
  fi
}

unset_varcolors() {
  unset RED GREEN YELLOW BLUE PURPLE CYAN NC RESET BOLD
  unset reset rst bold underline nounderline reverse
  unset black red green yellow blue magenta cyan white gray orange purple violet
  unset light_red light_green light_yellow light_blue light_magenta light_cyan light_white
  unset preto vermelho verde amarelo azul roxo ciano branca cinza laranja roxa violeta
  TICK="${white}[${verde}✓${rst}${white}]${rst}"
  CROSS="${white}[${roxa}✗${rst}${white}]${rst}"
  INFO="${white}[${cinza}i${rst}${white}]${rst}"
}

sh_checkroot() {
  if [[ "$(id -u)" != "0" ]]; then
    #alerta "$cdistro Linux installer" "${RED}${REVERSE}You should run this script as root!"
    #scrend 0
    elevate_to_root "$@"
  fi
}

elevate_to_root() {
  log_err "This script must be run as root. Elevating privileges..."
  ccabec+='root [elevated]'
  # Tenta usar sudo primeiro (caso esteja configurado)
  if command -v sudo >/dev/null 2>&1; then
    exec sudo bash "$0" "$@"
  fi
  # Se sudo falhar, tenta su
  if command -v su >/dev/null 2>&1; then
    exec su -c "$0 $*"
  fi
  die "Error: Unable to elevate privileges. Run manually as root."
}

replicate() {
  local char=${1:-'#'}
  local nsize=${2:-$(tput cols)}
  local line
  printf -v line "%*s" "$nsize" && echo -e "${blue}${line// /$char}${reset}"
}

msg()     { echo -e "${INFO} ${*}${reset}"; }
log_ok()  { echo -e "${TICK} ${*}${reset}"; }
log_err() { echo -e "${CROSS} ${*}${reset}"; }
die() {
  echo -e "${CROSS} ${red}${*}${reset}"
  exit 1
}

# configure ambiente
set_varcolors
sh_checkroot

##########################################################################################################

TMPDIR="/tmp/grub-btrfs"
mkdir -p "$TMPDIR"

OUTPUT="/tmp/grub-auto-entries.cfg"
> "$OUTPUT"

msg "Detectando partições Btrfs e EFI..."

# Detecta EFI
EFI_DEV=$(lsblk -lnpo NAME,FSTYPE,PARTFLAGS | grep -i "vfat" | grep -i "boot" | awk '{print $1}' | head -n1)
[ -n "$EFI_DEV" ] && log_ok "EFI detectada: $EFI_DEV"

# Detecta Btrfs
mapfile -t PARTS < <(lsblk -lnpo NAME,TYPE,FSTYPE)
for LINE in "${PARTS[@]}"; do
    read -r DEV TYPE FSTYPE <<< "$LINE"
    [ "$TYPE" != "part" ] && continue
    [ "$FSTYPE" != "btrfs" ] && continue

    msg "Tentando montar $DEV..."
    MNT="$TMPDIR/$(basename "$DEV")"
    mkdir -p "$MNT"

    if ! mount -o ro,subvol=@ "$DEV" "$MNT" 2>/dev/null; then
        log_err "Falhou ao montar $DEV subvol=@, pulando..."
        continue
    fi
    #log_ok "Montado $DEV com sucesso!"
    UUID=$(blkid -s UUID -o value "$DEV")

    # Pega GRUB_CMDLINE_LINUX_DEFAULT e GRUB_DISTRIBUTOR do /etc/default/grub da partição
    GRUB_DEFAULT_CMD=$(grep '^GRUB_CMDLINE_LINUX_DEFAULT=' "$MNT/etc/default/grub" 2>/dev/null | cut -d'=' -f2- | tr -d '"')
    GRUB_DISTRIBUTOR=$(grep '^GRUB_DISTRIBUTOR=' "$MNT/etc/default/grub" 2>/dev/null | cut -d'=' -f2- | tr -d '"')
    [ -z "$GRUB_DEFAULT_CMD" ] && GRUB_DEFAULT_CMD=""
    [ -z "$GRUB_DISTRIBUTOR" ] && GRUB_DISTRIBUTOR="Btrfs"

    # Detecta kernels
    for KERNEL in "$MNT"/boot/vmlinuz-*; do
      [ -f "$KERNEL" ] || continue
      KNAME=$(basename "$KERNEL")
      SUF="${KNAME#vmlinuz-}"

      # Procura initrd correspondente
      INAME=""
      for PFX in initrd- initramfs-; do
          for EXT in .img .gz; do
              if [ -f "$MNT/boot/${PFX}${SUF}${EXT}" ]; then
                  INAME="${PFX}${SUF}${EXT}"
                  break 2
              fi
          done
      done
      if [ -z "$INAME" ]; then
          log_err "Não achei initrd correspondente para $KNAME, pulando..."
          continue
      fi
#     msg "Kernel: $KNAME → Initrd: $INAME"

      cat >> "$OUTPUT" <<EOF-1
menuentry '$GRUB_DISTRIBUTOR on $DEV kernel $KNAME' --class chili --class gnu-linux --class gnu --class os \$menuentry_id_option 'gnulinux-simple-$UUID' {
  load_video
  set gfxpayload=keep
  insmod gzio
  insmod part_gpt
  insmod btrfs
EOF-1

        if [ -n "$EFI_DEV" ]; then
            EFIPATH="/EFI/$(basename $(lsblk -lnpo LABEL "$EFI_DEV" 2>/dev/null))/grubx64.efi"
            cat >> "$OUTPUT" <<EOF-2
  insmod fat
  set root=(hd0,gpt${EFI_DEV##*a})
  chainloader $EFIPATH
EOF-2
        fi

        # Linha do kernel com GRUB_CMDLINE_LINUX_DEFAULT
        cat >> "$OUTPUT" <<EOF-3
  search --no-floppy --fs-uuid --set=root $UUID
  echo 'Carregando o Linux $KNAME...'
  linux /@/boot/$KNAME root=UUID=$UUID rw rootflags=subvol=@ $GRUB_DEFAULT_CMD
  echo 'Carregando initrd $INAME...'
  initrd /@/boot/intel-ucode.img /@/boot/amd-ucode.img /@/boot/$INAME
}
EOF-3
    done

    umount "$MNT"
    rmdir "$MNT"
done

# -------------------------------
# Backup do 40_custom
# -------------------------------
CUSTOM="/etc/grub.d/40_custom"
BACKUP="/etc/grub.d/40_custom.bak.$(date +%s)"
msg "Fazendo backup do 40_custom em $BACKUP"
cp "$CUSTOM" "$BACKUP"

# Injeta as entradas geradas
msg "Injetando entradas em 40_custom..."
cat "$OUTPUT" >> "$CUSTOM"

# Atualiza GRUB
msg "Rodando update-grub..."
update-grub

# Restaura backup
msg "Restaurando backup do 40_custom..."
mv -f "$BACKUP" "$CUSTOM"

msg "Concluído! update-grub completo, Entradas btrfs adicionadas."

