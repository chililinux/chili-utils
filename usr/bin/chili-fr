#!/usr/bin/env bash
# -*- coding: utf-8 -*-
# shellcheck shell=bash disable=SC1091,SC2039,SC2166
#
#  chili-fr - Wrapper lite para o qemu
#  Created: 2019/12/13 - 00:00
#  Altered: 2024/10/03 - 00:00
#  Updated: dom 07 dez 2025 23:06:48 -04
#
#  Copyright (c) 2019-2025, Vilmar Catafesta <vcatafesta@gmail.com>
#  All rights reserved.
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions
#  are met:
#  1. Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
#  THIS SOFTWARE IS PROVIDED BY THE AUTHOR AS IS'' AND ANY EXPRESS OR
#  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
#  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
#  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
#  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
#  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
##############################################################################
export TEXTDOMAINDIR=/usr/share/locale
export TEXTDOMAIN=chili-fr
export TERM=${TERM:-xterm}
export TERM=${TERM:-xterm-256color}

#debug
export PS4='${red}${0##*/}${green}[$FUNCNAME]${pink}[$LINENO]${reset} '
#set -x
#set -e

#system
readonly APP="${0##*/}"
readonly VERSION='2.12.7-20251207'
readonly APPDESC='Wrapper lite para o qemu'
readonly -a DEPENDENCIES=(
	'tput'
	'qemu-system-x86_64'
	'spice-vdagent'
	'remote-viewer'
	'python3'
	'virsh'
	'find'
	'awk'
	'brctl'
)
readonly -A PACKAGEDEP=(
	['tput']='ncurses'
	['qemu-system-x86_64']='qemu-full'
	['spice-vdagent']='spice-vdagent'
	['remote-viewer']='virt-viewer'
	['python3']='python'
	['virsh']='libvirt'
	['find']='findutils'
	['awk']='gawk'
	['brctl']='bridge-utils'
)

declare HOME_DIR="$HOME/.chili-fr"
declare iface_bridge='br0'
declare bridge=false
declare xmem='8G'
declare videodevice='qxl'
declare videodevice='virtio-vga'
declare videodevice='VGA'
declare spice=false
declare only_tty=false
declare drive=false
declare uefi=false
declare vdisk=false
declare vdisk_name=''
declare netdevice='virtio-net-pci'
declare anetdevices=()
declare netchoosedriver=false
declare LC_DEFAULT=0
declare -i lastrow=$(tput lines)
declare -i lastcol=$(tput cols)
declare -i Prow=0
declare -i Pcol=0
declare -a qemu_options=()
declare -a avdisk_names=()
trap cleanup_working_dir EXIT

function cleanup_working_dir {
	if [[ -d "${working_dir}" ]]; then
		rm -rf -- "${working_dir}"
	fi
}

sh_setvarcolors() {
	if command -v "tput" &>/dev/null; then
		tput sgr0 # reset colors
		bold=$(tput bold)
		reset=$(tput sgr0)
		rst=$(tput sgr0)
		white="${bold}$(tput setaf 7)"
		black="${bold}$(tput setaf 0)"
		red=$(tput bold)$(tput setaf 196)
		green=$(tput setaf 2)
		yellow=$(tput bold)$(tput setaf 3)
		blue=$(tput setaf 4)
		pink=$(tput setaf 5)
		cyan=$(tput setaf 6)
		orange=$(tput setaf 3)
		purple=$(tput setaf 125)
		violet=$(tput setaf 61)
	else
		red="\033[01;31m"
		green="\033[01;32m"
		yellow="\033[01;33m"
		blue="\033[01;34m"
		pink="\033[01;35m"
		cyan="\033[01;36m"
		reset="\033[0m"
	fi
	COL_NC='\e[0m' # No Color
	COL_LIGHT_GREEN='\e[1;32m'
	COL_LIGHT_RED='\e[1;31m'
	#  TICK="${white}[${COL_LIGHT_GREEN}‚úì OK${COL_NC}${white}]"
	#	CROSS="${white}[${COL_LIGHT_RED}‚úóERR${COL_NC}${white}]"
	#	INFO="[i]"
	#	: "${clrkey=${rst}${light_white}}"
	: "${clrkey=${rst}${black}}"
	: "${TICK="${clrkey}[${green} ‚úì ${clrkey}]${rst}"}"
	: "${CROSS="${clrkey}[${red} ‚úó ${clrkey}]${rst}"}"
	: "${MID="${clrkey}[${red}‚úó‚úó${green}‚úì${clrkey}]${rst}"}"
	: "${WARN="${clrkey}[${yellow}‚ö†  ${clrkey}]${yellow}"}"
	: "${INFO="${clrkey}[${yellow}‚û°  ${clrkey}]${rst}"}"
	# shellcheck disable=SC2034
	DONE="${COL_LIGHT_GREEN} done!${COL_NC}"
	OVER="\\r\\033[K"
	DOTPREFIX="  ${black}::${reset} "
}

create_menu_with_array() {
	local title=$1
	local -a options=("${!2}") # Recebe o array de op√ß√µes
	local default=${3:-}       # Op√ß√£o padr√£o, se fornecida
	local selected=0
	local key

	options+=("Encerrar")
	# Define a op√ß√£o padr√£o como selecionada inicialmente
	if [[ -n "$default" ]]; then
		for i in "${!options[@]}"; do
			if [[ "${options[$i]}" == "$default" ]]; then
				selected=$i
				break
			fi
		done
	fi

	tput civis # Esconde o cursor

	while true; do
		tput clear # Limpa a tela
		echo -e "${blue}${bold}$title${rst}\n"

		for i in "${!options[@]}"; do
			if [[ "$i" -eq $selected ]]; then
				if [[ "${options[$i]}" =~ ^(Sair|Voltar|Encerrar|Abortar)$ ]]; then
					echo -e "${red}${bold}${reverse}> ${options[$i]}${rst}"
				else
					echo -e "${green}${bold}${reverse}> ${options[$i]}${rst}"
				fi
			else
				if [[ "${options[$i]}" =~ ^(Sair|Voltar|Encerrar|Abortar)$ ]]; then
					echo -e "${red}  ${options[$i]}${rst}"
				else
					echo "  ${options[$i]}"
				fi
			fi
		done

		read -rsn1 key
		case "$key" in
		A)
			((selected--))
			[ $selected -lt 0 ] && selected=$((${#options[@]} - 1))
			;;
		B)
			((selected++))
			[ $selected -eq ${#options[@]} ] && selected=0
			;;
		'') break ;;
		esac
	done

	tput cnorm # Mostra o cursor novamente
	#	echo -e "\nVoc√™ selecionou: ${green}${bold}${options[$selected]}${rst}"
	MENU_RESULT=${options[$selected]}
	if [[ "$MENU_RESULT" =~ ^(Sair|Voltar|Encerrar|Abortar)$ ]]; then
		die "$MENU_RESULT"
	fi
	#	return $((selected+1))
}

get() {
	local row="$1"
	local col="$2"
	local prompt="$3"
	local new_value="$4"
	local old_value="$5"
	local color="${Acores[box]}"

	# setpos "$row" "$col"
	printf "%s" "${reset}$color"
	read -p "${prompt}${reverse}" -e -i "$old_value" "$new_value"
	# tput sc # Salva a posi√ß√£o atual do cursor
	echo -n -e "$reset"
}

row() { echo "$Prow"; }
col() { echo "$Pcol"; }
lastrow() { echo "$(tput lines)"; }
lastcol() { echo "$(tput cols)"; }

setpos() {
	local row="$1"
	local col="$2"

	Prow="$row"
	Pcol="$col"
	# tput cup "$row" "$col"
	printf "\e[$((row + 1));$((col + 1))H"
}

sh_unsetvarcolors() {
	unset bold reset cyan red blue white black
	unset green yellow orange pink cyan purple violet
}

die() {
	local msg="$1"
	shift
	printf "%b %s\n" "${CROSS}" "${red}${msg}${rst}"
	exit 1
}

log_err() {
	printf "%b %s\n" "${CROSS}" "${*}"
}

log_ok() {
	printf "%b %s\n" "${TICK}" "${*}"
}

log_msg() {
	local retval="${PIPESTATUS[0]}"
	local pcount=$#

	((pcount >= 2)) && {
		retval=$1
		shift
	}
	if [[ $retval -eq 0 ]]; then
		printf "%b %s\n" "${TICK}" "${*}"
	else
		printf "%b %s\n" "${CROSS}" "${*}"
	fi
}

msg_raw() {
	local msg="$1"
	# Remove tags HTML, se existirem
	#msg="$(sed 's/<[^>]*>//g' <<< "$msg")"

	# Verifica se existe ':' na mensagem
	if [[ "$msg" == *:* ]]; then
		# Divide a string antes e depois do primeiro ':'
		local before_colon="${msg%%:*}:"
		local after_colon="${msg#*: }"
		# Aplica as cores
		msg="${cyan}${before_colon} ${red}${after_colon}${reset}"
	else
		# Se n√£o houver ':', aplica apenas a cor padr√£o
		msg="${yellow}${cyan}${msg}${reset}"
	fi
	echo -e "$msg"
}
export -f msg_raw

msg() {
	local msg="$1"
	msg="$(sed 's/<[^>]*>//g' <<<"$msg")" # Remove as tags HTML
	echo -e "  =>${cyan}running: ${yellow}${msg}${reset}"
}
export -f msg

msg_ok() {
	local msg="$1"
	#  echo -e "  =>${cyan}feito: ${green}${msg}${reset}"
	echo -e "${TICK} ${green}${*}${rst}"
}
export -f msg_ok

msg_run() {
	local msg="$1"
	echo -e "BP=>${cyan}running: ${yellow}${msg}${reset}"
	eval "$msg"
}
export -f msg_run

#msg_info() {
#	local msg="$*"
#	#local caller_function="${FUNCNAME[1]}" # Nome da fun√ß√£o que chamou a fun√ß√£o atual
#	#local caller_line="${BASH_LINENO[1]}"  # N√∫mero da linha que chamou a fun√ß√£o atual
#	#echo -e "${caller_function}=>${yellow}info   : ${cyan}${msg}${reset}"
#	#echo -e "${reset}  =>${yellow}info   : ${cyan}${msg}${reset}"
#	printf "%s\n" "${yellow}[WARN] ${cyan}$msg${rst}"
#}
#export -f msg_info

#msg_info() {  printf "%s\n" "${white}${pink}[INFO] ${rst}${*}${rst}"; }
msg_info() { echo -e "${INFO} ${*}${reset}"; }
msg() { echo -e "${INFO} ${*}${reset}"; }
log_ok() { echo -e "${TICK} ${*}${reset}"; }
log_err() { echo -e "${CROSS} ${*}${reset}"; }
log_mid() { echo -e "${MID} ${*}${reset}"; }
log_warn() { echo -e "${WARN} ${*}${reset}"; }
msg_info_tab() { echo -e "  ${INFO} ${*}${reset}"; }
msg_ex_tab() { echo -e "  üëâ   ${*}${reset}"; }
msg_ex() { echo -e "üëâ   ${*}${reset}"; }
msg_tab() { echo -e "  ${INFO} ${*}${reset}"; }
log_ok_tab() { echo -e "  ${TICK} ${*}${reset}"; }
log_err_tab() { echo -e "  ${CROSS} ${*}${reset}"; }
log_mid_tab() { echo -e "  ${MID} ${*}${reset}"; }
log_warn_tab() { echo -e "  ${WARN} ${*}${reset}"; }
die() {
	echo -e "${CROSS} ${red}${*}${reset}"
	exit 1
}

msg_warning() {
	local msg="$*"
	#	echo -e "  =>${yellow}warning: ${cyan}${msg}${reset}"
	echo -e "${WARN} ${*}${reset}"
}
export -f msg_warning

msg_warn() {
	local msg="$1"
	#	printf "%s\n" "${yellow}[WARN] ${cyan}$msg${rst}"
	echo -e "${WARN} ${*}${reset}"
}
export -f msg_warn

# Fun√ß√£o para exibir mensagens informativas
msg_err() {
	#	printf "%s\n" "${red}[ERRO] ${cyan}$1${rst}"
	echo -e "${CROSS} ${*}${reset}"
}

replicate() {
	local char=${1:-'#'}
	local nsize=${2:-$(tput cols)}
	local ccolor=${3:-$green}
	local line
	printf -v line "%*s" "$nsize" && echo -e "${ccolor}${line// /$char}${rst}"
}
export -f replicate

maxcol() {
	COLUMNS=$(stty size)
	COLUMNS=${COLUMNS##* }
	((COLUMNS <= 0)) && COLUMNS=80
	echo "$COLUMNS"
}

readconf() {
	local msg="$1"
	local color="${2:-${red}}"

	echo -n -e "$color"
	if [[ $LC_DEFAULT -eq 0 ]]; then
		read -r -p "$msg [S/n]"
	else
		read -r -p "$msg [Y/n]"
	fi
	echo -n -e "$reset"
	case "${REPLY^}" in
	[SY]) return 0 ;;
	"") return 0 ;;
	*) return 1 ;;
	esac
}

sh_checkDependencies() {
	local aBlock_files=()
	local d
	local errorFound=false
	declare -a missing

	for d in "${DEPENDENCIES[@]}"; do
		if ! command -v "$d" &>/dev/null; then
			log_err "Check: ${red}ERROR${rst}: N√£o foi poss√≠vel encontrar o comando ${cyan}'$d'${rst} -> instalar pacote ${cyan}${PACKAGEDEP[$d]}${rst}"
			missing+=("$d")
			errorFound=true
		else
			#log_msg "Check: ${cyan}$d"
			:
		fi
	done

	if $errorFound; then
		replicate '='
		echo "${yellow}             IMPOSS√çVEL CONTINUAR"
		echo "${black}Este script precisa dos comandos listados acima"
		echo "${black}Instale-os e/ou verifique se eles est√£o em seu ${red}\$PATH${rst}"
		replicate '='
		if readconf "Deseja instalar os pacotes e criar os arquivos necess√°rios ?"; then
			sh_setup
		fi
	fi
}
export -f sh_checkDependencies

sh_checkVdiskFiles() {
	local aBlock_files=()
	local d
	local errorFound=false
	declare -a missing

	aBlock_files+=($HOME_DIR/vdisk/sda.img)
	aBlock_files+=($HOME_DIR/vdisk/sdb.img)
	aBlock_files+=($HOME_DIR/vdisk/sdc.img)
	aBlock_files+=($HOME_DIR/vdisk/sdd.img)
	aBlock_files+=($HOME_DIR/vdisk/vda.qcow2)
	aBlock_files+=($HOME_DIR/vdisk/vdb.qcow2)
	aBlock_files+=($HOME_DIR/vdisk/vdc.qcow2)
	aBlock_files+=($HOME_DIR/vdisk/vdd.qcow2)
	for d in "${aBlock_files[@]}"; do
		if [[ ! -e "$d" ]]; then
			sh_createVdiskFiles
			break
		fi
	done
}

sh_checkOVMFFiles() {
	local aBlock_files=()
	local d
	local errorFound=false
	declare -a missing

	aBlock_files+=('/usr/share/edk2/x64/OVMF_CODE.4m.fd')
	aBlock_files+=('/usr/share/edk2/x64/OVMF_VARS.4m.fd')
	for d in "${aBlock_files[@]}"; do
		if [[ ! -e "$d" ]]; then
			log_err "Check: ${red}ERROR${reset}: N√£o foi poss√≠vel encontrar o arquivo ${cyan}'$d'${yellow} -> instalar pacote ${cyan}edk2-ovmf${reset}"
			errorFound=true
			break
		else
			true
			log_msg "Check: ${cyan}$d"
			:
		fi
	done

	if $errorFound; then
		replicate '='
		echo "${yellow}             FALHA DO CHECK LIST FILE"
		echo "${black}Este script precisa dos arquivos para UEFI listados acima"
		echo "${black}Instale-os e/ou verifique se eles est√£o em ${yellow}/usr/share/edk2/x64/${rst}"
		echo "${black}Ao decidir n√£o instalar, o UEFI poder√° n√£o funcionar corretamente.${rst}"
		replicate '='
		if readconf "Deseja instalar o pacote e suprir arquivos necess√°rios ?"; then
			sudo pacman -S --quiet --noconfirm edk2-ovmf 1>/dev/null
		fi
	fi
}

# Fun√ß√£o para verificar se a interface TAP j√° existe e retornar o pr√≥ximo n√∫mero dispon√≠vel
get_next_free_tap() {
	local next_tap=1
	while ip link show "tap$next_tap" &>/dev/null; do
		next_tap=$((next_tap + 1))
	done
	echo "tap$next_tap"
}

# Fun√ß√£o para verificar se a bridge existe e retornar o pr√≥ximo nome dispon√≠vel
get_next_free_bridge() {
	local base_bridge="virbr"
	local next_bridge=1
	while ip link show "$base_bridge$next_bridge" &>/dev/null; do
		next_bridge=$((next_bridge + 1))
	done
	echo "$base_bridge$next_bridge"
}

# ---------------------------
# cmd_sudo wrapper
# ---------------------------
cmd_sudo() {
	if [[ $EUID -eq 0 ]]; then
		"$@"
	else
		sudo "$@"
	fi
}

ensure_qemu_bridge_allowed() {
	local br="$1"
	local conf="/etc/qemu/bridge.conf"

	# se arquivo n√£o existe ‚Äî cria
	if [[ ! -f "$conf" ]]; then
		# Garantir que /etc/qemu existe
		cmd_sudo mkdir -p /etc/qemu &>/dev/null
		cmd_sudo sh -c "echo 'allow ${br}' > '$conf'"
		return 0
	fi

	# verifica se j√° est√° presente (ignora espa√ßos e duplicidades)
	if cmd_sudo grep -Eq "^[[:space:]]*allow[[:space:]]+${br}[[:space:]]*$" "$conf"; then
		msg_ok "Bridge ${cyan}'${br}'${rst} j√° est√° permitida no $conf"
		return 0
	fi

	# adicionar no final do arquivo
	msg_info "Adicionando 'allow ${br}' em $conf"
	cmd_sudo sh -c "echo 'allow ${br}' >> '$conf'"
	return 0
}

######################################################################################################
#  BRIDGE REAL (tipo VirtualBox) ‚Äì sem NAT
######################################################################################################
create_real_bridge() {
	local bridge_name="$1"
	local iface_phys
	local old_con
	local kernel_master
	local use_dhcp=false
	local bridge_ip
	local bridge_gw

	[[ -z "$bridge_name" ]] && {
		msg_err "Uso correto: --create_real_bridge br0"
		return 1
	}

	msg_info "Verificando se a bridge '$bridge_name' j√° existe"
	if ip link show "$bridge_name" &>/dev/null; then
		msg_warning "Bridge '${bridge_name}' j√° existe ‚Äî nada a fazer."
		cmd_sudo nmcli connection show
		return 0
	fi

	# DETECTAR INTERFACES F√çSICAS (ETHERNET)
	###########################################################################
	msg_info "Detectando interfaces f√≠sicas (ethernet)"
	local -a eth_list
	mapfile -t eth_list < <(
		nmcli -t -f DEVICE,TYPE device | awk -F: '$2=="ethernet"{print $1}'
	)

	if [[ ${#eth_list[@]} -eq 0 ]]; then
		msg_err "Nenhuma interface ethernet dispon√≠vel. WLAN n√£o suporta bridge real."
		return 1
		#  elif [[ ${#eth_list[@]} -eq 1 ]]; then
		#    iface_phys="${eth_list[0]}"
		#    msg_info "Apenas uma interface f√≠sica encontrada: $iface_phys"
	else
		msg_info "M√∫ltiplas interfaces encontradas ‚Äî exibindo menu de sele√ß√£o"
		create_menu_with_array "Escolha a interface f√≠sica para a bridge:" eth_list[@]
		iface_phys="$MENU_RESULT"
		if [[ "$iface_phys" == "Encerrar" ]]; then
			msg_info "Opera√ß√£o cancelada pelo usu√°rio."
			return 1
		fi
		msg_info "Interface selecionada: $iface_phys"
	fi

	# PROTE√á√ÉO ‚Äî INTERFACE N√ÉO PODE SER WLAN
	###########################################################################
	if nmcli -t -f DEVICE,TYPE device | grep -q "^${iface_phys}:wifi$"; then
		msg_err "A interface '$iface_phys' √© Wi-Fi. Bridge real n√£o funciona com WLAN."
		return 1
	fi

	# VERIFICAR SE INTERFACE J√Å √â SLAVE
	###########################################################################
	msg_info "Verificando se '$iface_phys' j√° pertence a outra bridge"
	kernel_master=$(ip -o link show "$iface_phys" | sed -n 's/.*master \([^ ]*\).*/\1/p' || true)
	if [[ -n "$kernel_master" ]]; then
		msg_err "Interface '$iface_phys' j√° pertence √† bridge '$kernel_master'."
		msg_warning "Remova primeiro: chili-fr -r $kernel_master"
		return 1
	fi

	# MENU VLAN
	###########################################################################
	msg_info "Configura√ß√£o de VLAN"
	local -a vlan_options=(
		"Sem VLAN (rede normal)"
		"VLAN Tagged (criar ${iface_phys}.<id> e usar como slave)"
		"VLAN Trunk (bridge vlan-filtering habilitado)"
	)
	create_menu_with_array "Selecione o modo VLAN:" vlan_options[@]

	local vlan_choice
	case "$MENU_RESULT" in
	"Sem VLAN (rede normal)") vlan_choice="none" ;;
	"VLAN Tagged (criar ${iface_phys}.<id> e usar como slave)") vlan_choice="tagged" ;;
	"VLAN Trunk (bridge vlan-filtering habilitado)") vlan_choice="trunk" ;;
	*)
		msg_err "Erro inesperado no menu VLAN"
		return 1
		;;
	esac
	msg_info "Modo VLAN selecionado: ${cyan}$vlan_choice${rst}"

	local vlan_id="" slave_iface="" want_vlan_trunk=false
	if [[ "$vlan_choice" == "tagged" ]]; then
		while true; do
			get 0 0 "Digite o VLAN ID (1‚Äì4094): " vlan_id ""
			if [[ "$vlan_id" =~ ^[0-9]+$ && "$vlan_id" -ge 1 && "$vlan_id" -le 4094 ]]; then
				slave_iface="${iface_phys}.${vlan_id}"
				msg_info "Subinterface VLAN definida: $slave_iface"
				break
			fi
			msg_err "VLAN inv√°lida: informe um n√∫mero entre 1 e 4094."
		done

	elif [[ "$vlan_choice" == "trunk" ]]; then
		want_vlan_trunk=true
		msg_info "Bridge atuar√° como trunk (vlan-filtering)."

		local vlan_list_raw
		while true; do
			get 0 0 "Informe VLANs permitidas separadas por v√≠rgula (ex: 10,20,30): " vlan_list_raw ""
			vlan_list_raw="${vlan_list_raw// /}"
			IFS=',' read -r -a trunk_vlans <<<"$vlan_list_raw"
			local ok=true
			declare -A _seen=()
			for v in "${trunk_vlans[@]}"; do
				if ! [[ "$v" =~ ^[0-9]+$ && "$v" -ge 1 && "$v" -le 4094 ]]; then
					msg_err "VLAN inv√°lida: $v"
					ok=false
					break
				fi
				if [[ -n "${_seen[$v]}" ]]; then
					msg_err "VLAN duplicada: $v"
					ok=false
					break
				fi
				_seen[$v]=1
			done
			[[ "$ok" == true ]] && break
		done
	fi

	# CAPTURAR IP/GW
	###########################################################################
	if [[ -n "$slave_iface" ]]; then
		msg_info "Tentando detectar IP na subinterface VLAN '$slave_iface'"
		bridge_ip=$(nmcli -g IP4.ADDRESS device show "$slave_iface" 2>/dev/null | head -n1 || true)
		bridge_gw=$(nmcli -g IP4.GATEWAY device show "$slave_iface" 2>/dev/null | head -n1 || true)
		if [[ -z "$bridge_ip" ]]; then
			msg_info "Usando IP da interface f√≠sica '$iface_phys'"
			bridge_ip=$(nmcli -g IP4.ADDRESS device show "$iface_phys" | head -n1)
			bridge_gw=$(nmcli -g IP4.GATEWAY device show "$iface_phys")
		fi
	else
		msg_info "Obtendo IP atual da interface ${cyan}'$iface_phys'${rst}"
		bridge_ip=$(nmcli -g IP4.ADDRESS device show "$iface_phys" | head -n1)
		bridge_gw=$(nmcli -g IP4.GATEWAY device show "$iface_phys")
	fi

	if [[ -z "$bridge_ip" ]]; then msg_warning "Nenhum IP detectado automaticamente."; fi
	if [[ -z "$bridge_gw" ]]; then msg_warning "Nenhum gateway detectado."; fi

	local original_ip_pure="${bridge_ip%%/*}"

	# SOLICITAR E VALIDAR IP
	###########################################################################
	msg_info "Configurando IP da bridge ${cyan}'$bridge_name'${rst}"

	if readconf "Usar DHCP?"; then
		use_dhcp=true
	else
		while true; do
			get 0 0 "IP (ex 192.168.2.70/24): " tmp_ip "$bridge_ip"
			bridge_ip="${tmp_ip:-$bridge_ip}"

			if [[ ! "$bridge_ip" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}/[0-9]{1,2}$ ]]; then
				msg_err "Formato inv√°lido."
				continue
			fi

			local candidate_ip="${bridge_ip%%/*}"
			if [[ "$candidate_ip" == "$original_ip_pure" ]]; then
				msg_info "IP igual ao atual ‚Äî pulando teste."
				break
			fi

			msg_info "Validando se IP est√° em uso..."
			if command -v arping >/dev/null 2>&1; then
				if cmd_sudo arping -c2 -w1 -I "$iface_phys" "$candidate_ip" >/dev/null 2>&1; then
					msg_err "Conflito ARP detectado."
					continue
				else
					break
				fi
			fi
			break
		done

		while true; do
			get 0 0 "Gateway (ex 192.168.2.1): " tmp_gw "$bridge_gw"
			bridge_gw="${tmp_gw:-$bridge_gw}"
			if [[ ! "$bridge_gw" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]; then
				msg_err "Gateway inv√°lido."
				continue
			fi
			if ! ping -c1 -W1 "$bridge_gw" >/dev/null; then
				msg_warning "Gateway n√£o respondeu."
				readconf "Continuar?" && break || continue
			fi
			break
		done
	fi

	# CRIAR BRIDGE E SLAVE
	###########################################################################
	msg_info "Criando bridge ${cyan}'$bridge_name'${rst}"
	cmd_sudo nmcli connection add type bridge ifname "$bridge_name" con-name "$bridge_name" \
		stp no ipv6.method ignore autoconnect yes >/dev/null || {
		msg_err "Falha ao criar bridge"
		return 1
	}

	local slave_to_use
	if [[ -n "$slave_iface" ]]; then
		if ! ip link show "$slave_iface" &>/dev/null; then
			msg_info "Criando subinterface VLAN $slave_iface"
			cmd_sudo nmcli connection add type vlan ifname "$slave_iface" dev "$iface_phys" id "$vlan_id" \
				con-name "vlan-${iface_phys}.${vlan_id}" ipv4.method disabled ipv6.method ignore >/dev/null || {
				msg_err "Falha ao criar VLAN"
				return 1
			}
			sleep 1
		fi
		slave_to_use="$slave_iface"
	else
		slave_to_use="$iface_phys"
	fi

	# criar slave da bridge apontando para slave_to_use
	msg_info "Criando conex√£o slave para ${cyan}'$slave_to_use'${rst}"
	local slave_name="${bridge_name}-${slave_to_use}-$(uuidgen | cut -c1-8)"

	cmd_sudo nmcli connection add type bridge-slave ifname "$slave_to_use" con-name "$slave_name" \
		master "$bridge_name" autoconnect yes >/dev/null || {
		msg_err "Falha ao criar slave '$slave_name'"
		return 1
	}

	# VLAN TRUNK
	###########################################################################
	if [[ "$vlan_choice" == "trunk" ]]; then
		msg_info "Ativando vlan-filtering"
		cmd_sudo nmcli connection modify "$bridge_name" bridge.vlan-filtering yes

		for v in "${trunk_vlans[@]}"; do
			msg_info "Adicionando VLAN $v ao trunk"
			cmd_sudo bridge vlan add dev "$iface_phys" vid "$v" master "$bridge_name" 2>/dev/null ||
				msg_warning "Falha ao adicionar VLAN $v"
		done
	fi

	# DESATIVAR CONEX√ÉO ANTIGA
	###########################################################################
	msg_info "Desativando conex√£o antiga da interface f√≠sica"
	old_con=$(nmcli -t -f NAME,DEVICE connection show | grep ":$iface_phys$" | cut -d: -f1 || true)
	if [[ -n "$old_con" ]]; then
		cmd_sudo nmcli connection down "$old_con" &>/dev/null
		cmd_sudo nmcli connection modify "$old_con" connection.autoconnect no
	fi

	# CONFIGURAR IP NA BRIDGE
	###########################################################################
	if [[ "$use_dhcp" == true ]]; then
		msg_info "Ativando DHCP na bridge ${cyan}'$bridge_name'${rst}"
		cmd_sudo nmcli connection modify "$bridge_name" ipv4.method auto ipv4.never-default no >/dev/null
	else
		msg_info "Aplicando IP manual"
		cmd_sudo nmcli connection modify "$bridge_name" \
			ipv4.method manual \
			ipv4.addresses "$bridge_ip" \
			ipv4.gateway "$bridge_gw" \
			ipv4.dns-search "" \
			ipv6.method ignore >/dev/null
	fi

	# ATIVAR A BRIDGE
	###########################################################################
	msg_info "Ativando bridge ${cyan}'$bridge_name'${rst}"
	cmd_sudo nmcli connection up "$bridge_name" >/dev/null

	# RESUMO
	###########################################################################
	msg_info_tab "${green}---------- RESUMO ----------${rst}"
	msg_info_tab "Bridge           : ${green}$bridge_name${rst}"
	msg_info_tab "Interface f√≠sica : ${green}$iface_phys${rst}"
	msg_info_tab "Slave            : ${green}$slave_to_use${rst}"
	msg_info_tab "Conex√£o slave    : ${green}$slave_name${rst}"

	case "$vlan_choice" in
	none) msg_info_tab "VLAN             : ${green}nenhuma${rst}" ;;
	tagged) msg_info_tab "VLAN Tagged      : ${green}$vlan_id${rst}" ;;
	trunk) msg_info_tab "Trunk            : ${green}VLANs ${trunk_vlans[*]}${rst}" ;;
	esac

	if [[ "$use_dhcp" == true ]]; then
		msg_info_tab "IP               : ${green}DHCP${rst}"
	else
		msg_info_tab "IP aplicado      : ${green}$bridge_ip${rst}"
		msg_info_tab "Gateway          : ${green}$bridge_gw${rst}"
	fi

	msg_info_tab "${green}-----------------------------${rst}"
	ensure_qemu_bridge_allowed "$bridge_name"
	msg_ok "Bridge ${cyan}'$bridge_name'${rst} criada e configurada com sucesso."
	return 0
}

remove_real_bridge() {
	local bridge_name="$1"
	local iface_phys
	local slave_con
	local bridge_ip
	local bridge_gw

	[[ -z "$bridge_name" ]] && {
		msg_err "Uso: chili-fr -r br0"
		return 1
	}

	# DETECTAR INTERFACE F√çSICA SLAVE
	###########################################################################
	msg_info "Removendo bridge '$bridge_name' com seguran√ßa (sem derrubar SSH)"
	iface_phys=$(ip -o link show | grep -w "master $bridge_name" | awk -F: '{print $2}' | awk '{print $1}')
	#   iface_phys=$(
	#     ip -o link show \
	#     | awk -v br="$bridge_name" '
	#         $0 ~ ("master " br) {
	#           split($2, a, ":");
	#           print a[1];
	#           exit;
	#         }
	#       '
	#   )

	if [[ -z "$iface_phys" ]]; then
		msg_err "N√£o foi poss√≠vel detectar interface f√≠sica slave."
		return 1
	fi

	msg_info "Interface f√≠sica slave detectada: ${cyan}$iface_phys${rst}"

	# ACHAR PERFIL SLAVE (f√°cil)
	###########################################################################
	slave_con=$(
		nmcli -t -f NAME,TYPE connection show 2>/dev/null |
			grep -m1 "^${bridge_name}-${iface_phys}.*802-3-ethernet" |
			cut -d: -f1
	)

	if [[ -z "$slave_con" ]]; then
		msg_warning "Nenhum perfil slave encontrado ‚Äî talvez j√° removido."
	else
		msg_info "Perfil slave encontrado: ${cyan}$slave_con${rst}"
	fi

	###########################################################################
	# PEGAR IP E GATEWAY ATUAIS DA BRIDGE
	###########################################################################
	bridge_ip=$(nmcli -g IP4.ADDRESS device show "$bridge_name" | head -n1)
	bridge_gw=$(nmcli -g IP4.GATEWAY device show "$bridge_name" | head -n1)

	msg_info "IP atual na bridge: ${cyan}${bridge_ip:-nenhum}${rst}"
	msg_info "Gateway: ${cyan}${bridge_gw:-nenhum}${rst}"

	# IDENTIFICAR PERFIL F√çSICO CORRETO  (teu m√©todo definitivo)
	###########################################################################
	phys_con=$(
		nmcli -t -f NAME,DEVICE,TYPE,SLAVE connection show |
			awk -F: -v dev="$interface" '
        $3 ~ /802-3-ethernet/ && ($2 == dev || $2 == "") && $4 != "bridge" {print $1; exit}
    '
	)

	if [[ -z "$phys_con" ]]; then
		msg_err "N√£o foi poss√≠vel localizar o perfil f√≠sico verdadeiro para '$iface_phys'."
		return 1
	fi
	msg_info "Perfil f√≠sico real: ${cyan}$phys_con${rst}"

	# RESTAURAR AUTOCONNECT + IP NA F√çSICA (ANTES DE REMOVER A BRIDGE)
	###########################################################################
	msg_info_tab "Restaurando autoconnect da interface f√≠sica"
	cmd_sudo nmcli connection modify "$phys_con" connection.autoconnect yes

	if [[ -n "$bridge_ip" ]]; then
		msg_info_tab "Aplicando IP ($bridge_ip) de volta na interface f√≠sica"
		cmd_sudo nmcli connection modify "$phys_con" ipv4.method manual
		cmd_sudo nmcli connection modify "$phys_con" ipv4.addresses "$bridge_ip"
		[[ -n "$bridge_gw" ]] && cmd_sudo nmcli connection modify "$phys_con" ipv4.gateway "$bridge_gw"
	else
		msg_info_tab "Sem IP detectado ‚Äî configurando interface f√≠sica para DHCP"
		cmd_sudo nmcli connection modify "$phys_con" ipv4.method auto
	fi

	# SUBIR INTERFACE F√çSICA AGORA (ANTES DE REMOVER A BRIDGE)
	###########################################################################
	msg_info_tab "Subindo interface f√≠sica ANTES de remover a bridge"
	echo -n "$green"
	cmd_sudo nmcli connection up "$phys_con" || msg_warning "Falha ao subir interface f√≠sica ‚Äî pode ser esperado via SSH"
	echo -n "$rst"

	# REMOVER PERFIL SLAVE
	###########################################################################
	if [[ -n "$slave_con" ]]; then
		msg_info_tab "Removendo conex√£o slave '$slave_con'"
		echo -n "$green"
		cmd_sudo nmcli connection delete "$slave_con"
		echo -n "$rst"
	fi

	# REMOVER A BRIDGE
	###########################################################################
	msg_info_tab "Desativando bridge '$bridge_name'"
	echo -n "$green"
	cmd_sudo nmcli connection down "$bridge_name" 2>/dev/null
	echo -n "$rst"

	msg_info_tab "Removendo perfil da bridge"
	echo -n "$green"
	cmd_sudo nmcli connection delete "$bridge_name" 2>/dev/null
	echo -n "$rst"

	msg_ok "Bridge '$bridge_name' removida com sucesso e interface '$iface_phys' restaurada."
}

create_bridge_virbr() {
	local bridge_name="$1"

	if sudo virsh -c qemu:///system net-list --all &>/dev/null; then
		msg_info "virsh est√° funcionando e conseguiu listar as redes."
	else
		msg_warning "virsh n√£o conseguiu se conectar ao libvirt."
		msg_warning "Verifique se o servi√ßo libvirtd est√° ativo com os comandos abaixo:\n\
sudo systemctl status libvirtd.service
sudo systemctl status libvirtd.socket"
		msg_warning "DICA: Tente ativar com os comandos abaixo:\n\
sudo systemctl enable --now libvirtd virtqemud
sudo systemctl restart libvirtd.service"
		die "Erro fatal"
	fi

	if [[ -z "$bridge_name" ]]; then
		# Obter o pr√≥ximo nome de bridge dispon√≠vel
		bridge_name=$(get_next_free_bridge)
	fi

	# Criar a rede virsh correspondente √† nova bridge
	if sudo virsh net-list --all 1>/dev/null; then
		if ! sudo virsh net-list --all | grep -q "$bridge_name" 1>/dev/null; then
			msg_info "Criando a rede $bridge_name..."

			# Calcular a faixa de IP com base no nome da bridge
			# O n√∫mero da bridge ser√° extra√≠do (ex: virbr1 -> 1, virbr2 -> 2, etc.)
			bridge_number=$(echo "$bridge_name" | grep -o '[0-9]*')
			base_ip="172.$((30 + bridge_number)).255.1"
			GATEWAY="$base_ip"
			subnet="255.255.255.0"
			dhcp_range_start="172.$((30 + bridge_number)).255.2"
			dhcp_range_end="172.$((30 + bridge_number)).255.200"

			# Criando o arquivo de configura√ß√£o tempor√°rio para a rede
			tmp_net_config=$(mktemp)

			cat <<EOF >"$tmp_net_config"
<!--
WARNING: THIS IS AN AUTO-GENERATED FILE. CHANGES TO IT ARE LIKELY TO BE
OVERWRITTEN AND LOST. Changes to this xml configuration should be made using:
  virsh net-edit $bridge_name
or other application using the libvirt API.
-->

<network>
  <name>$bridge_name</name>
  <uuid>$(uuidgen)</uuid>
  <forward mode='nat'/>
  <bridge name='$bridge_name' stp='on' delay='0'/>
  <ip address='$base_ip' netmask='$subnet'>
    <dhcp>
      <range start='$dhcp_range_start' end='$dhcp_range_end'/>
    </dhcp>
  </ip>
</network>
EOF
			# Definir a rede usando o arquivo tempor√°rio
			sudo virsh net-define "$tmp_net_config" 1>/dev/null
			# Remover o arquivo de configura√ß√£o tempor√°rio ap√≥s a defini√ß√£o
			sudo rm -f "$tmp_net_config"
		fi
	else
		die "erro fatal!"
	fi

	# Tornar a nova bridge persistente
	msg_info "Tornando $bridge_name persistente..."
	msg_info "Iniciando a rede $bridge_name..."
	sudo virsh net-autostart "$bridge_name" 1>/dev/null

	if ! sudo virsh net-start "$bridge_name" 1>/dev/null; then
		msg_err "Falha ao iniciar a rede $bridge_name. Tentando novamente."
		sudo virsh net-destroy "$bridge_name" 1>/dev/null
		sudo virsh net-start "$bridge_name" 1>/dev/null
	fi

	# Obter o pr√≥ximo nome de interface TAP dispon√≠vel
	#tap_name=$(get_next_free_tap)-"$bridge_name"
	tap_name="tap-$bridge_name"

	# Criar a interface TAP (ex: tap0, tap1, tap2...)
	msg_info "Criando a interface TAP $tap_name..."
	sudo ip tuntap add dev "$tap_name" mode tap 1>/dev/null

	# Colocar a interface TAP para up
	msg_info "Ativando a interface TAP $tap_name..."
	sudo ip link set "$tap_name" up 1>/dev/null

	# Adicionar a interface TAP √† bridge rec√©m-criada
	msg_info "Adicionando $tap_name √† bridge $bridge_name..."
	sudo brctl addif "$bridge_name" "$tap_name" 1>/dev/null

	# Verificar se a bridge e o TAP foram configurados corretamente
	msg_info "Verificando a associa√ß√£o de interfaces √† bridge $bridge_name..."
	brctl show "$bridge_name" 1>/dev/null

	# Exibir as interfaces para verificar se tudo est√° funcionando
	msg_info "Verificando as interfaces de rede..."
	ip addr show "$bridge_name" 1>/dev/null
	ip addr show "$tap_name" 1>/dev/null

	sudo virsh net-info "$bridge_name"
	msg_info "Configura√ß√£o conclu√≠da!"
	exit
}

remove_virbr_bridge_and_tap() {
	local bridge_name="$1"
	local tap_name

	#tap_name="tap$(echo "$bridge_name" | sed 's/[^0-9]*//g')" # Ajuste para pegar o n√∫mero correto do tap
	tap_name="tap-$bridge_name"

	# Remover a bridge
	msg_info "Removendo a bridge $bridge_name..."
	sudo ip link set "$bridge_name" down 1>/dev/null
	sudo brctl delbr "$bridge_name" 1>/dev/null

	# Remover a interface TAP associada
	if ip link show "$tap_name" &>/dev/null; then
		msg_info "Removendo a interface TAP $tap_name..."
		sudo ip link set "$tap_name" down 1>/dev/null
		sudo ip tuntap del dev "$tap_name" mode tap 1>/dev/null
	else
		msg_err "A interface TAP $tap_name n√£o existe."
	fi

	# Remover a rede do libvirt
	msg_info "Removendo a rede do libvirt..."
	sudo virsh net-destroy "$bridge_name" 1>/dev/null
	sudo virsh net-autostart --disable "$bridge_name" 1>/dev/null
	sudo virsh net-undefine "$bridge_name" 1>/dev/null
	sudo ip link delete "$bridge_name" 1>/dev/null
	sudo systemctl restart libvirtd 1>/dev/null

	# Remover a configura√ß√£o da rede do libvirt, caso fique residuos
	local network_config="/etc/libvirt/qemu/networks/${bridge_name}.xml"
	local network_config_autostart="/etc/libvirt/qemu/networks/autostart/${bridge_name}.xml"
	msg_info "Removendo o arquivo de configura√ß√£o da rede $bridge_name..."
	sudo rm -fv "$network_config" 1>/dev/null
	sudo rm -fv "$network_config_autostart" 1>/dev/null

	sudo virsh net-info "$bridge_name" 1>/dev/null
	msg_ok "Bridge $bridge_name e TAP $tap_name removidos com sucesso."
	exit 0
}

######################################################################################################

# Fun√ß√£o para obter as interfaces do tipo bridge
get_bridge_interfaces() {
	#  brctl show | awk 'NR > 1 {printf "%s ", $1}'
	#	brctl show | awk 'NR > 1 {printf "%s ", $1}' | sed 's/ $//'
	ip -o link show type bridge | awk -F': ' '{print $2}'
}

list_bridges_detailed() {
	ip -o link show type bridge |
		awk '
   {
     name=$2; sub(":", "", name)
     state=""; mac=""

     # captura STATE e MAC
     for (i=1; i<=NF; i++) {
       if ($i=="state") state=$(i+1)
       if ($i=="link/ether") mac=$(i+1)
     }

     # pegar IP usando getline e analisando "line" (o certo!)
     ip=""
     cmd = "ip -o -4 addr show dev " name " 2>/dev/null"
     while ((cmd | getline line) > 0) {
       split(line, f, " ")
       for (k=1; k<=length(f); k++) {
         if (f[k] == "inet") {
           ip = f[k+1]
         }
       }
     }
     close(cmd)

     printf "  %-20s %-8s %-20s %-18s\n", name, state, mac, ip
   }'
}

# Fun√ß√£o para obter os arquivos RAW no diret√≥rio $HOME_DIR/vdisk/
get_raw_images() {
	local dir="${HOME_DIR:-$HOME}/vdisk"
	# Lista os arquivos com extens√£o .img, removendo o caminho e separando por espa√ßo
	#  find "$dir" -maxdepth 1 -type f -name "*.img" -exec basename {} \; | tr '\n' ' ' | sed 's/ $//'
	find "$dir" -maxdepth 1 -type f \( -name "*.img" -o -name "*.qcow2" \) -exec basename {} \; | tr '\n' ' ' | sed 's/ $//'
}

supports_uefi() {
	fdisk -l "$1" 2>/dev/null | grep -q "EFI"
}

detect_distro() {
	local id=""

	if [[ -r /etc/os-release ]]; then
		# L√™ ID=void|arch|debian|... exatamente como a distro declara
		id=$(grep -E '^ID=' /etc/os-release | cut -d= -f2 | tr -d '"')
	elif [[ -r /usr/lib/os-release ]]; then
		id=$(grep -E '^ID=' /usr/lib/os-release | cut -d= -f2 | tr -d '"')
	else
		echo "unknown"
		return
	fi
	echo "$id"
}

detect_audio_server() {
	if pgrep -x pipewire >/dev/null; then
		echo "pipewire"
	elif pgrep -x pulseaudio >/dev/null; then
		echo "pa"
	elif pgrep -x jackd >/dev/null; then
		echo "jack"
	else
		echo "none"
	fi
}

sh_version() {
	cat <<-EOF
		${bold}${cyan}${0##*/} v${VERSION}${rst}
		${APPDESC}
		${VERSION}
		${bold}${black}Copyright (C) 2019-2025 ChiliLinux Development Team${black}
		${bold}${black}Copyright (C) 2019-2025 Vilmar Catafesta${black}

		  Este √© um software livre: voc√™ √© livre para alter√°-lo e redistribu√≠-lo.
		  O $APP √© disponibilizado para voc√™ sob a ${yellow}Licen√ßa MIT${black}, e
		  inclui software de c√≥digo aberto sob uma variedade de outras licen√ßas.
		  Voc√™ pode ler instru√ß√µes sobre como baixar e criar para voc√™ mesmo
		  o c√≥digo fonte espec√≠fico usado para criar esta c√≥pia.
		  ${red}Este programa vem com absolutamente NENHUMA garantia.
		  ${rst}
	EOF
	exit 0
}

function sh_usage {
	cat <<EOF
uso: ${orange}$APP${reset} [Op√ß√µes]
${cyan}Op√ß√µes:${reset}
  ${rst}-b|--bridge ${orange}<name>                     ${cyan}# inicia rede em modo bridge - ex: -b br0 (default: NAT)
  ${rst}-c|--create_real_bridge ${orange}<name>         ${cyan}# criar real bridge - ex: -c br0
  ${rst}-r|--remove_real_bridge ${orange}<name>         ${cyan}# remover real bridge - ex: -r br0
  ${rst}   --create_virbr_bridge ${orange}<name>        ${cyan}# criar virbr bridge - ex: --create_virbr_bridge br0
  ${rst}   --remove_virbr_bridge ${orange}<name>        ${cyan}# remover virbr bridge - ex: --remove_virbr_bridge br0
  ${rst}-d|--drive ${orange}<device>                    ${cyan}# anexa disco externo - ex: -d /dev/sdX (default: none)
  ${rst}-m|--memory ${orange}<mem>                      ${cyan}# mem√≥ria inicial de convidado - ex: -m 16G (default: 8GB)
  ${rst}-v|--vdisk ${orange}<filename.img|qcow2>        ${cyan}# usa um disco virtual interno - ( default: none)
  ${rst}   --cvdisk ${orange}<filename>                 ${cyan}# cria um disco virtual para uso interno
  ${rst}   --rvdisk ${orange}<filename>                 ${cyan}# remove um disco virtual
  ${rst}-g|--video ${orange}<video_driver>              ${cyan}# virtio-vga,virtio-gpu-pci,qxl-vga,VGA,cirrus-vga,ati-vga,virtio-gpu-pci,bochs-display - default: VGA
  ${rst}-N|--network ${orange}<net_driver>              ${cyan}# virtio-net-pci,e1000,rtl8139,vmxnet3 (default: virtio-pc)
  ${rst}-n|--nocolor                           ${cyan}# remover cores da sa√≠da - (default: color)
  ${rst}-s|--spice                             ${cyan}# ativar o spice - (default: desligado)
  ${rst}-t|--tty                               ${cyan}# ativar modo tty only - (default: desligado)
  ${rst}-l|--list                              ${cyan}# listar discos virtuais
  ${rst}-u|--uefi                              ${cyan}# inicializa√ß√£o em UEFI - (default: BIOS)
  ${rst}-V|--version                           ${cyan}# exibe a vers√£o do aplicativo
  ${rst}-h|--help                              ${cyan}# imprime este ajuda
${cyan}Exemplos:${rst}
  $ ${orange}$APP${reset} -u -b br0 file.iso          ${cyan}#Execute uma imagem, em ponte, usando UEFI ${rst}
  $ ${orange}$APP${reset} -u -s -b br0 file.iso       ${cyan}#Execute uma imagem, em ponte, usando spice, usando UEFI ${rst}
  $ ${orange}$APP${reset} -u file.img                 ${cyan}#Execute uma imagem, em NAT, usando UEFI ${rst}
  $ ${orange}$APP${reset} -b br0 /dev/sdX             ${cyan}#Execute uma device, em ponte, usando UEFI ${rst}
  $ ${orange}$APP${reset} -u -m 16G -b br0 /dev/sdX   ${cyan}#Execute uma device, em ponte, 16Gb mem√≥ria, usando UEFI ${rst}
  $ ${orange}$APP${reset} -a pipewire /dev/sdX        ${cyan}#Execute uma device, em NAT, usando audio pipewire ${rst}
  $ ${orange}$APP${reset} file.iso                    ${cyan}#Execute uma imagem usando BIOS${rst}
  $ ${orange}$APP${reset} -b file.img                 ${cyan}#Execute uma imagem, em ponte, usando BIOS ${rst}
  $ ${orange}$APP${reset} -m 16G /dev/sdX             ${cyan}#Execute uma device, 16GB mem√≥ria, usando BIOS ${rst}
${cyan}Forma de uso mais comum:${rst}
  $ ${orange}$APP${reset} filename.iso ${rst}
  $ ${orange}$APP${reset} -u filename.iso ${rst}
  $ ${orange}$APP${reset} /dev/sdX ${rst}
  $ ${orange}$APP${reset} -u /dev/sdX ${rst}
  $ ${orange}$APP${reset} -d /dev/sdX filename.iso ${rst}
  $ ${orange}$APP${reset} -u -d /dev/sdX filename.iso ${rst}
  $ ${orange}$APP${reset} -v vdisk_name.img filename.iso ${rst}
  $ ${orange}$APP${reset} -u -v vdisk_name.img filename.iso ${rst}
  $ ${orange}$APP${reset} $HOME_DIR/vdisk/vdisk_name.img ${rst}
${cyan}acesso a vm/convidado via ssh:${rst}
  $ ${rst} ssh live@vsock/555                 ${cyan}# via vsock ${rst}
  $ ${rst} ssh live@127.0.0.1 -p 60022        ${cyan}# via redirecionamento ${rst}
  $ ${rst} ssh <ip_vm>                        ${cyan}# via bridge (caso vm iniciada com -b) ${rst}
  $ ${rst} ssh $USER@127.0.0.1 -p 60022    ${cyan}# via redirecionamento ${rst}
EOF
	exit 0
}

sh_createVdiskFiles() {
	local aBlockDisk=(sda.img sdb.img sdc.img sdd.img)
	local aBlockDiskQcow2=(vda.qcow2 vdb.qcow2 vdc.qcow2 vdd.qcow2)
	local file

	if [[ ! -d "$HOME_DIR/vdisk/" ]]; then
		msg_info "Criando diret√≥rios de trabalho"
		mkdir -p "$HOME_DIR/vdisk/" &>/dev/null
	fi

	msg_info "Setando permiss√µes no diret√≥rios de trabalho"
	sudo chmod 1777 "$HOME_DIR/" &>/dev/null

	for file in "${aBlockDisk[@]}"; do
		if [[ ! -e $HOME_DIR/vdisk/$file ]]; then
			msg_info "Criando disco virtual '$file' no diret√≥rios de trabalho"
			qemu-img create $HOME_DIR/vdisk/$file -f raw 32G &>/dev/null
		fi
	done
	for file in "${aBlockDiskQcow2[@]}"; do
		if [[ ! -e $HOME_DIR/vdisk/$file ]]; then
			msg_info "Criando disco virtual '$file' no diret√≥rios de trabalho"
			qemu-img create -f qcow2 $HOME_DIR/vdisk/$file 32G &>/dev/null
		fi
	done
}

sh_setup() {
	local DISTRO=$(detect_distro)
	msg_info "Instalando necess√°rios pacotes"

	case "$DISTRO" in
	void)
		msg_ex "Rodando no VOID üê∫"
		if ! cmd_sudo xbps-install -Sy \
			qemu \
			edk2-ovmf \
			ncurses \
			spice-vdagent \
			virt-viewer \
			python \
			libvirt \
			findutils \
			gawk \
			bridge-utils \
			seabios \
			1>/dev/null 2>&1; then
			die "[ERRO] Falha ao instalar pacotes."
		fi
		;;
	chililinux | arch)
		msg_ex "Rodando no ${DISTRO^^}  ARCH üèπ"
		cmd_sudo pacman -S --needed --quiet --noconfirm \
			qemu-full \
			edk2-ovmf \
			ncurses \
			spice-vdagent \
			virt-viewer \
			python \
			libvirt \
			findutils \
			gawk \
			bridge-utils \
			seabios 1>/dev/null
		;;
	manjaro) : ;;
	debian) : ;;
	ubuntu) : ;;
	ubuntu) : ;;
	fedora) : ;;
	endeavouros) : ;;
	*)
		echo "Outra distro: $DISTRO"
		;;
	esac

	sh_createVdiskFiles
	sh_start_vdagentd "$DISTRO"
}

sh_create_vdisk_file() {
	msg_info "Criando diret√≥rios de trabalho"
	mkdir -p "$HOME_DIR/vdisk" &>/dev/null
	msg_info "Setando permiss√µes no diret√≥rios de trabalho"
	sudo chmod 1777 "$HOME_DIR/" &>/dev/null
	sudo chown $USER:$USER "$HOME_DIR/" -R &>/dev/null

	while true; do
		sh_list_vdisks
		get 10 10 "Entre com o nome do disco (sem extens√£o) - ex vda  : " cvdisk_name
		get 11 10 "Entre com o tamanho do disco virtual em GB - ex 32 : " cvdisk_size

		if test -e $HOME_DIR/vdisk/$cvdisk_name.img &>/dev/null; then
			if readconf "Disco virtual j√° existe, escolha outro nome. Tentar novamente?"; then
				continue
			fi
		else
			if qemu-img create $HOME_DIR/vdisk/$cvdisk_name.img -f raw "$cvdisk_size"G &>/dev/null; then
				msg_ok "Disco virtual '$HOME_DIR/vdisk/$cvdisk_name.img' criado com sucesso"
				echo -n $green
				ls -lh $HOME_DIR/vdisk
				echo -n $rst
				replicate '='
			else
				die "Falha na cria√ß√£o do disco virtual $HOME_DIR/vdisk/$cvdisk_name.img"
			fi
		fi
		break
	done
}

sh_list_vdisks() {
	replicate "================== DISCOS VIRTUAIS DISPON√çVEIS em $HOME_DIR/vdisk ===================" 1
	echo -n $green
	ls -lh $HOME_DIR/vdisk
	echo -n $rst
	replicate '='
}

sh_remove_vdisk_file() {
	msg_info "Criando diret√≥rios de trabalho"
	mkdir -p "$HOME_DIR/vdisk" &>/dev/null
	msg_info "Setando permiss√µes no diret√≥rios de trabalho"
	sudo chmod 1777 "$HOME_DIR/" &>/dev/null
	sudo chown $USER:$USER "$HOME_DIR/" -R &>/dev/null

	sh_list_vdisks
	get 10 10 "Entre com o nome do disco para remover - ex vda.img : " cvdisk_name

	if test -e $HOME_DIR/vdisk/$cvdisk_name &>/dev/null; then
		if readconf "PERGUNTA: Deseja realmente excluir o disco virtual ?"; then
			if rm -f $HOME_DIR/vdisk/$cvdisk_name &>/dev/null; then
				msg_ok "Disco virtual '$HOME_DIR/vdisk/$cvdisk_name' foi removido com sucesso"
				exit 0
			fi
		fi
		exit $?
	else
		die "Disco virtual digitado n√£o existe"!
	fi
}

sh_start_vdagentd() {
	local DISTRO=$(detect_distro)

	if ! pgrep spice-vdagentd; then
		msg_info "Ativando servi√ßo spice-vdaagentd na distro: ${cyan}${DISTRO^^}"
		case "$DISTRO" in
		void)
			cmd_sudo ln -sf /etc/sv/spice-vdagentd /var/service/ &>/dev/null
			;;
		chililinux | arch)
			cmd_sudo systemctl enable -now spice-vdagentd &>/dev/null
			;;
		*)
			msg_info_tab "Outra distro: $DISTRO"
			;;
		esac
	fi
}

# saber se o sistema est√° num TTY puro ou num ambiente gr√°fico
is_graphical() {
	# Wayland ou X11
	[[ "$XDG_SESSION_TYPE" == "x11" || "$XDG_SESSION_TYPE" == "wayland" ]] && return 0
	[[ -n "$DISPLAY" || -n "$WAYLAND_DISPLAY" ]] && return 0
	return 1
}

sh_copyright() {
	echo -n $orange
	echo "$APP - v${VERSION} - ${APPDESC}"
	echo 'Copyright (c) 2019-2025, ChiliLinux Development Team <https://chililinux.com> <https://github.com/chililinux>'
	echo 'Copyright (c) 2019-2025, Vilmar Catafesta <vcatafesta@gmail.com>'
	echo $rst
}

print_avaiable_bridges() {
	local bridges
	#	bridges=($(get_bridge_interfaces))
	mapfile -t bridges < <(list_bridges_detailed)

	echo -e "${cyan}Bridges dispon√≠veis:${rst}"
	if [[ ${#bridges[@]} -eq 0 ]]; then
		echo -e "  ${yellow}(nenhuma bridge dispon√≠vel)${rst}"
	else
		for b in "${bridges[@]}"; do
			echo -e "  ${yellow}${b}${rst}"
		done
	fi
}

add_smb_share() {
	local share_dir="$HOME/share" # opcional, por padr√£o $HOME/share
	local cCmd=''

	# se tiver smbd, cria share e adiciona a op√ß√£o (OBS: smb s√≥ funciona no modo -net user)
	if command -v smbd &>/dev/null; then
		mkdir -p "$share_dir" &>/dev/null
		cCmd=",smb=${share_dir}"
	fi
	echo $cCmd
}

print_summary_access_vm() {
	msg_info "acesso a vm/convidado via ssh:"
	msg_info_tab "$ ssh live@vsock/$GUEST_CID                     ${cyan}# via vsock"
	msg_info_tab "$ ssh live@127.0.0.1 -p $HOST_FWD            ${cyan}# via redirecionamento"
	msg_info_tab "$ ssh ${violet}<ip_vm>                            ${cyan}# via bridge (caso vm iniciada com -b) ${rst}"
	msg_info_tab "$ ssh $USER@127.0.0.1 -p $HOST_FWD      ${cyan}# via redirecionamento"
}

function sh_start_with_spice() {
	sh_start_vdagentd

	# Informar as portas usadas
	msg_info_tab "SPICE running on port : ${cyan}$random_spice_port${rst}"
	msg_info_tab "Cliente SPICE (GUI)   : ${cyan}remote-viewer spice://localhost:$random_spice_port${rst}"

	# Configurar SPICE
	#qemu_options+=(-chardev spicevmc,id=vdagent,debug=0,name=vdagent)
	#qemu_options+=(-device virtserialport,chardev=vdagent,name=com.redhat.spice.0)
	qemu_options+=(
		-spice port=$random_spice_port,disable-ticketing=on
		-monitor tcp:localhost:$random_port,server,nowait
		-chardev spicevmc,id=charchannel0,name=vdagent
		-device virtserialport,chardev=charchannel0,name=com.redhat.spice.0
		-display none
	)

	# Executar o QEMU
	sudo env XDG_RUNTIME_DIR=/run/user/$(id -u) qemu-system-x86_64 "${qemu_options[@]}" &
	qemu_pid=$!
	remote-viewer spice://localhost:$random_spice_port &
	viewer_pid=$!

	# Aguardar o remote-viewer e encerrar o QEMU quando ele fechar
	wait $viewer_pid
	kill $qemu_pid &>/dev/null
}

main() {
	#	local img="$1"
	local params=("$@")
	local img
	local random_port="$(shuf -i 4444-45000 -n 1)"
	local random_spice_port="$(shuf -i 5900-5910 -n 1)"
	local cache_type
	local bootindex
	local media_type
	local count=1
	local devices=()

	# Anexar discos/imagens
	for img in "${params[@]}"; do
		# Verificar se a imagem foi especificada
		[[ -z "$img" ]] && {
			sh_list_vdisks
			die "Erro: vdisk/iso/device #${count} n√£o especificada!"
		}
		if [[ ! -e "$img" ]]; then
			[[ ! -e "$HOME_DIR/vdisk/$img" ]] && {
				log_msg 1 "Check: ${yellow}dispositivo #${count}: ${cyan}$img"
				sh_list_vdisks
				die "Erro: vdisk/iso/device #${count} ${cyan}${img} ${red}n√£o localizada, tente os listados acima!${reset}"
			}
			img="$HOME_DIR/vdisk/$img"
		fi
		devices+=("$img")
		log_msg true "Check: ${yellow}dispositivo #${count}: ${cyan}$img"
		((++count))
	done

	# For√ßar UEFI, se solicitado
	if $uefi; then
		sh_checkOVMFFiles
		msg_info "For√ßando inicializa√ß√£o UEFI..."
		#[[ ! -e $HOME_DIR/OVMF_VARS.4m.fd ]] && cp -f /usr/share/edk2-ovmf/x64/OVMF_VARS.4m.fd $HOME_DIR/
		cp -f /usr/share/edk2-ovmf/x64/OVMF_VARS.4m.fd $HOME_DIR/
		qemu_options+=(-drive if=pflash,format=raw,readonly=on,file=/usr/share/edk2/x64/OVMF_CODE.4m.fd)
		qemu_options+=(-drive if=pflash,format=raw,file=$HOME_DIR/OVMF_VARS.4m.fd)
	fi

	# Adicionar op√ß√µes padr√£o do QEMU
	qemu_options+=(-no-fd-bootchk)
	qemu_options+=(-machine accel=kvm)
	qemu_options+=(-cpu host)
	qemu_options+=(-smp "$(nproc)")
	qemu_options+=(-m ${xmem})
	qemu_options+=(-k pt-br)

	#Modo	            Vantagens	                                              Desvantagens
	#cache=none	      Seguro, evita inconsist√™ncias	                          Pode ser mais lento
	#cache=writeback	Boa performance, mant√©m um n√≠vel aceit√°vel de seguran√ßa	Risco de perda de dados em caso de falha
	#cache=directsync	Seguran√ßa m√°xima (grava direto no disco)	              Muito mais lento
	#cache=unsafe	    M√°xima performance	                                    Pode corromper dados se houver falha

	cache_type='writeback'
	bootindex=1 # √çndice de boot inicial

	for img in "${devices[@]}"; do
		media_type=$(file -b --mime-type "${img}")
		#		qemu_options+=(-boot menu=on)
		if [[ "${media_type}" == "application/x-iso9660-image" ]]; then
			msg_info "Anexando iso #${bootindex}: ${yellow}${img}"
			qemu_options+=(-drive file="${img}",if=none,id=cdrom${bootindex},media=cdrom)
			qemu_options+=(-device ide-cd,drive=cdrom${bootindex},bootindex=${bootindex})
			((bootindex++))
		elif [[ "${img}" == *.qcow2 ]]; then
			msg_info "Anexando vdisk #${bootindex}: ${yellow}${img}"
			qemu_options+=(-drive file="${img}",if=none,id=disk${bootindex},format=qcow2,cache=${cache_type})
			qemu_options+=(-device virtio-blk,drive=disk${bootindex},bootindex=${bootindex})
			((bootindex++))
		elif [[ "${img}" == /dev/* ]]; then
			qemu_options+=(-drive file="${img}",if=none,id=disk${bootindex},format=raw,media=disk,cache=${cache_type})
			qemu_options+=(-device virtio-blk,drive=disk${bootindex},bootindex=${bootindex})
			msg_info "Anexando device #${bootindex}: ${yellow}${img}"
			((bootindex++))
		else
			msg_info "Anexando vdisk #${bootindex}: ${yellow}${img}"
			#			qemu_options+=(-drive file="${img}",if=none,id=disk${bootindex},format=raw,cache=${cache_type})
			#			qemu_options+=(-device virtio-blk,drive=disk${bootindex},bootindex=${bootindex})
			qemu_options+=(-drive file="${img}",if=none,id=disk${bootindex},format=raw)
			qemu_options+=(-device ahci,id=sata${bootindex})
			qemu_options+=(-device ide-hd,drive=disk${bootindex},bus=sata${bootindex}.0,bootindex=${bootindex})
			((bootindex++))
		fi
	done

	if $vdisk; then
		for vdsk in "${avdisk_names[@]}"; do
			[[ ! -e "$vdsk" ]] && vdsk="$HOME_DIR/vdisk/$vdsk"
			[[ ! -e "$vdsk" ]] && continue

			if [[ "${vdsk}" == *.img ]]; then
				msg_info "Anexando vdisk #${bootindex}: ${yellow}${vdsk}"
				qemu_options+=(-drive file="${vdsk}",if=none,id=disk${bootindex},format=raw,cache=${cache_type})
				qemu_options+=(-device virtio-blk,drive=disk${bootindex},bootindex=${bootindex})
				((bootindex++))
			elif [[ "${vdsk}" == *.qcow2 ]]; then
				msg_info "Anexando vdisk #${bootindex}: ${yellow}${vdsk}"
				qemu_options+=(-drive file="${vdsk}",if=none,id=disk${bootindex},format=qcow2,cache=${cache_type})
				qemu_options+=(-device virtio-blk,drive=disk${bootindex},bootindex=${bootindex})
				((bootindex++))
			fi
		done
	else
		#		msg_warn "Parametro --vdisk n√£o informado, iniciando sem disco virtual..."
		:
	fi

	#	qemu_options+=(-name "chili-fr $*",process=archiso_0)
	qemu_options+=(-name "chili-fr")

	#video
	# CONFIGURA√á√ÉO DE DISPLAY (GTK s√≥ se GUI existir)
	if $only_tty; then
		#/etc/default/grub
		#GRUB_TERMINAL="console"
		#GRUB_GFXPAYLOAD_LINUX=text
		#GRUB_CMDLINE_LINUX="console=tty1 nomodeset"

		# Console interativo no terminal
		qemu_options+=(
			-vga std
			-display curses
		)
	else
		qemu_options+=(-device virtio-scsi-pci,id=scsi0)
		qemu_options+=(-audiodev "$(detect_audio_server)",id=snd0)
		qemu_options+=(-rtc base=localtime,clock=host)
		qemu_options+=(-device ich9-intel-hda)
		qemu_options+=(-device hda-output,audiodev=snd0)
		qemu_options+=(-global ICH9-LPC.disable_s3=1)
		qemu_options+=(-machine type=q35,smm=on,accel=kvm,usb=on,pcspk-audiodev=snd0)
		#	qemu_options+=(-device intel-iommu)
		qemu_options+=(-device "$videodevice")
		qemu_options+=(-display gtk,gl=on)
		qemu_options+=(-device virtio-serial)
	fi

	if $spice; then
		sh_start_with_spice
		exit 0
	else
		if $only_tty; then
			#echo "${qemu_options[@]}" # ;  exit 0
			cmd_sudo env XDG_RUNTIME_DIR=/run/user/$(id -u) qemu-system-x86_64 "${qemu_options[@]}"
			exit 0
		else
			#echo "${qemu_options[@]}" # ;  exit 0
			sudo env XDG_RUNTIME_DIR=/run/user/$(id -u) qemu-system-x86_64 "${qemu_options[@]}"
			exit 0
		fi
	fi
}
export -f main

params="${@}"
sh_setvarcolors
#sh_copyright

# Display usage information if no arguments are passed
if [[ $# -eq 0 || $1 == @(-h|--help) ]]; then
	sh_usage
fi
if [[ $1 == @(-V|--version) ]]; then
	sh_version
fi

sh_checkDependencies
sh_checkVdiskFiles

OPTIONS=m:ub:Vnhd:stg:v:i:N:c:r:l
LONGOPTIONS=memory:,uefi,bridge:,version,nocolor,help,drive:,spice,tty,video:,image:,network:,create_virbr_bridge:,remove_virbr_bridge:,create_real_bridge:,remove_real_bridge:,cvdisk,rvdisk,vdisk,list
opts=($(getopt --options="$OPTIONS" --longoptions="$LONGOPTIONS" --name "$0" -- "$@"))
eval set -- "${opts[*]}"

while test ${#opts[*]} -gt 0; do
	case $1 in
	-n | --nocolor)
		sh_unsetvarcolors
		;;
	-u | --uefi)
      msg_info "Parametro ${cyan}--uefi${rst} detectado: tentando usar uefi ${rst}"

		uefi=true
		;;
	-i | --image)
		if [[ -z "$2" ]]; then
			die "Argumento inv√°lido para ${1}, falta par√¢metro de imagem/disco/device" >&2
		else
			img="$2"
			shift
		fi
		;;
	-c | --create_real_bridge)
		if [[ -z "$2" ]]; then
			die "Argumento inv√°lido para --create_real_bridge. Ex: --create_real_bridge br0"
		else
			create_real_bridge "$2"
			exit 0
		fi
		;;
	-r | --remove_real_bridge)
		if [[ " $(get_bridge_interfaces) " =~ "$2" ]]; then
			bridge_name="$2"
			remove_real_bridge "$bridge_name"
			exit 0
		else
			echo -e "${red}Erro:${rst} Argumento inv√°lido para ${cyan} ${1} ${rst}" >&2
			print_avaiable_bridges
			exit 1
		fi
		;;
	--create_virbr_bridge)
		if [[ -z "$2" ]]; then
			die "Argumento inv√°lido para --create_virbr_bridge, falta nome para bridge \nEx.: --create_virbr_bridge br0" >&2
		else
			if [[ " $(get_bridge_interfaces) " =~ "$2" ]]; then
				die "Argumento inv√°lido para ${cyan}--create_virbr_bridge${red}. BRIDGE ${cyan}$2 ${red}j√° existe" >&2
			else
				bridge_name="$2"
				create_virbr_bridge "$bridge_name"
				shift
			fi
		fi
		;;
	--remove_virbr_bridge)
		if [[ " $(get_bridge_interfaces) " =~ "$2" ]]; then
			bridge_name="$2"
			remove_virbr_bridge_and_tap "$bridge_name"
			shift
		else
			echo -e "${red}Erro:${rst} Argumento inv√°lido para ${cyan}${1}${rst}" >&2
			print_avaiable_bridges
			exit 1
		fi
		;;
	-b | --bridge)
		if [[ " $(get_bridge_interfaces) " =~ "$2" ]]; then
			iface_bridge="$2"
			msg_info "Parametro ${cyan}--bridge${rst} detectado: tentando usar bridge ${cyan}'$iface_bridge'${rst}"
			bridge=true
			shift
		else
			echo -e "${red}Erro:${rst} Argumento inv√°lido para ${cyan}${1}${rst}" >&2
			print_avaiable_bridges
			exit 1
		fi
		;;
	-s | --spice)
		spice=true
		log_msg "Parametro --spice detectado: tentando usar spice..."
		;;
	-t | --tty)
		spice=false
		log_msg "Parametro --tty detectado: ativando tty only..."
		only_tty=true
		;;
	-g | --video)
		if [[ $2 =~ ^(virtio-vga|virtio-gpu-pci|qxl-vga|VGA|cirrus-vga|ati-vga|virtio-gpu-pci|bochs-display|ramfb)?$ ]]; then
			videodevice="$2"
			shift
		else
			die "Argumento inv√°lido para -v. Use VGA,virtio-vga,virtio-gpu-pci,qxl-vga,cirrus-vga,ati-vga,virtio-gpu-pci,bochs-display ou ramfb" >&2
		fi
		;;
	-l | --list)
		sh_list_vdisks
		exit 0
		:
		;;
	-v | --vdisk)
		if [[ " $(get_raw_images) " =~ " $2 " || -e "$2" ]]; then
			vdisk_name="$2"
			avdisk_names+=("$vdisk_name")
			vdisk=true
			shift
		else
			sh_list_vdisks
			die "Argumento inv√°lido para ${cyan}--vdisk ${rst}V√°lidos s√£o: ${yellow}$(get_raw_images)${rst}" >&2
		fi
		;;
	--cvdisk)
		sh_create_vdisk_file
		exit $?
		;;
	--rvdisk)
		sh_remove_vdisk_file
		exit $?
		;;
	-N | --network)
		if [[ $2 =~ ^(virtio-net-pci|e1000|rtl8139|vmxnet3|ne2k_pci|ne2k_isa|pcnet|smc91c111|i82551|i82557b|i82559er)?$ ]]; then
			netdevice="$2"
			anetdevices+=("$netdevice")
			netchoosedriver=true
			msg_info "Anexando placa de rede, driver: ${yellow}$netdevice"
			shift
		else
			die "Argumento inv√°lido para --network. Use virtio-net-pci,e1000,rtl8139,vmxnet3,ne2k_pci,ne2k_isa,pcnet,smc91c111,i82551,i82557b,i82559er" >&2
		fi
		;;
	-d | --drive)
		if [[ -n $2 ]]; then
			drive=true
			drive_path=$2
			if lsblk $drive_path &>/dev/null; then
				log_msg "Parametro -d,--drive detectado: $drive_path"
			else
				die "${cyan}Parametro -d,--drive => ${red}$drive_path: n√£o √© um dispositivo de bloco"
			fi
			shift
		else
			die "Argumento inv√°lido para --drive. Use formato device, como /dev/sdX (por exemplo)." >&2
		fi
		;;
	-m | --memory)
		if [[ $2 =~ ^[0-9]+[MG]?$ ]]; then
			xmem=$2
			log_msg "Parametro -m/--memory detectado: $2"
			shift
		else
			die "Argumento inv√°lido para -m. Use um formato como 16G (por exemplo)." >&2
		fi
		;;
	--)
		shift
		break
		;;
	:)
		die "-$OPTARG requer um argumento" >&2
		;;
	*)
		die "opera√ß√£o n√£o suportada: $1 (usar -h para ajuda"
		;;
	esac
	shift
done

if [[ $# > 0 ]]; then
	# Configurar rede
	#random_mac_net0=$(python3 -c "import random; print(':'.join(['{:02x}'.format(random.randint(0, 255)) for _ in range(6)]))")
	#random_mac_net1=$(python3 -c "import random; print(':'.join(['{:02x}'.format(random.randint(0, 255)) for _ in range(6)]))")
	#mkdir -p $HOME/share &>/dev/null
	#qemu_options+=(-netdev bridge,id=net0,smb=$HOME)
	#qemu_options+=(-netdev bridge,id=net0)
	#qemu_options+=(-device e1000,netdev=net0)
	#qemu_options+=(-device e1000,netdev=net0,mac=$random_mac_net0)
	#qemu_options+=(-netdev bridge,id=net1,br=$iface_bridge)
	#qemu_options+=(-device e1000,netdev=net1,mac=$random_mac_net1)
	#qemu_options+=(-netdev tap,ifname=tap1,script=no,downscript=no,id=net0)
	#qemu_options+=(-device virtio-net-device,netdev=net0,mac=92:7b:15:c3:4d:ec)

	# intervalo de 555 a 560 ‚Üí tamanho = 560‚àí555+1 = 6
	export GUEST_CID=$((RANDOM % 6 + 555))
	export HOST_FWD=$((RANDOM % 6 + 60022))

	if ! $uefi; then
		msg_warn "Parametro --uefi n√£o informado, usando BIOS legacy (padr√£o)..."
	fi

	if ! is_graphical; then
		msg_warn "Nenhum ambiente gr√°fico detectado ‚Äî for√ßando modo TTY."
		spice=false
		only_tty=true
	fi

	if $netchoosedriver; then
		for netdevice in "${anetdevices[@]}"; do
			((nId++))
			netdev_id="net$nId"
			if $bridge; then
				qemu_options+=(-netdev bridge,id="$netdev_id",br=$iface_bridge)
			else
				if $spice; then
					qemu_options+=(-netdev user,id="$netdev_id")
				else
					qemu_options+=(-netdev user,id="$netdev_id",hostfwd=tcp::$HOST_FWD-:22"$(add_smb_share)")
				fi
			fi
			qemu_options+=(-device "$netdevice",netdev="$netdev_id")
		done
		qemu_options+=(-device vhost-vsock-pci,id=vhost-vsock-pci0,guest-cid=$GUEST_CID)
	else
		netdev_id="net0"
		if $bridge; then
			qemu_options+=(-netdev bridge,id="$netdev_id",br=$iface_bridge)
		else
			if $spice; then
				qemu_options+=(-netdev user,id="$netdev_id")
			else
				qemu_options+=(-netdev user,id="$netdev_id",hostfwd=tcp::$HOST_FWD-:22"$(add_smb_share)")
			fi
		fi
		qemu_options+=(-device "$netdevice",netdev="$netdev_id")
		qemu_options+=(-device vhost-vsock-pci,id=vhost-vsock-pci0,guest-cid=$GUEST_CID)
	fi
	print_summary_access_vm

	#windows
	qemu_options+=(-usb -device usb-tablet)

	if $drive; then
		msg_info "Anexando disco/drive externo: ${yellow}$drive_path"
		qemu_options+=(-drive file=$drive_path,format=raw,media=disk)
	fi
	main "$@"
else
	log_err "${red}Erro${rst}: Falta par√¢metro de imagem/disco/device. ${cyan}Tente os vdisks listados abaixo. ${yellow}(usar -h para ajuda)"
	msg_ex_tab "${green}$ ${reset}${APP} ${params} ${rst}vda.img"
	msg_ex_tab "${green}$ ${rst}${APP} ${params} ${rst}/path/filename.img|qcow2|iso|raw"
	msg_ex_tab "${green}$ ${rst}${APP} ${params} ${rst}/dev/sdX"
	msg_ex_tab "${green}$ ${rst}${APP} ${params} ${rst}filename.iso /dev/sdX"
	sh_list_vdisks
fi
