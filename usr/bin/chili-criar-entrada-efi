#!/usr/bin/env bash
# -*- coding: utf-8 -*-
# shellcheck shell=bash disable=SC1091,SC2039,SC2166
#
#  chili-criar-entrada-efi
#  Created: 2025/05/02 - 11:53
#  Altered: 2025/05/02 - 11:53
#
#  Copyright (c) 2025-2025, Vilmar Catafesta <vcatafesta@gmail.com>
#  All rights reserved.
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions
#  are met:
#  1. Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
#  THIS SOFTWARE IS PROVIDED BY THE AUTHOR AS IS'' AND ANY EXPRESS OR
#  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
#  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
#  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
#  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
#  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
##############################################################################
#export LANGUAGE=pt_BR
export TEXTDOMAINDIR=/usr/share/locale
export TEXTDOMAIN=chili-criar-entrada-efi

# Definir a vari√°vel de controle para restaurar a formata√ß√£o original
reset=$(tput sgr0)

# Definir os estilos de texto como vari√°veis
bold=$(tput bold)
underline=$(tput smul)   # In√≠cio do sublinhado
nounderline=$(tput rmul) # Fim do sublinhado
reverse=$(tput rev)      # Inverte as cores de fundo e texto

# Definir as cores ANSI como vari√°veis
black=$(tput bold)$(tput setaf 0)
red=$(tput bold)$(tput setaf 196)
green=$(tput bold)$(tput setaf 2)
yellow=$(tput bold)$(tput setaf 3)
blue=$(tput setaf 4)
pink=$(tput setaf 5)
magenta=$(tput setaf 5)
cyan=$(tput setaf 6)
white=$(tput setaf 7)
gray=$(tput setaf 8)
orange=$(tput setaf 202)
purple=$(tput setaf 125)
violet=$(tput setaf 61)
light_red=$(tput setaf 9)
light_green=$(tput setaf 10)
light_yellow=$(tput setaf 11)
light_blue=$(tput setaf 12)
light_magenta=$(tput setaf 13)
light_cyan=$(tput setaf 14)
bright_white=$(tput setaf 15)

#debug
export PS4='${red}${0##*/}${green}[$FUNCNAME]${pink}[$LINENO]${reset}'
#set -x
#set -e
shopt -s extglob

#system
declare APP="${0##*/}"
declare _VERSION_="1.0.0-20250502"
declare APPDESC="bash - Wraper for "
declare distro="$(uname -n)"
declare DEPENDENCIES=(tput)
declare dialogRcFile="/home/vcatafesta/.dialogrc"

cleanup() { rm -f ""; }
#trap cleanup EXIT
MostraErro() { echo "erro: ${red}$1${reset} => comando: ${cyan}'$2'${reset} => result=${yellow}$3${reset}";}
trap 'MostraErro "$APP[$FUNCNAME][$LINENO]" "$BASH_COMMAND" "$?"; exit 1' ERR

sh_create_dialogrc() {
  cat > "$dialogRcFile" <<EOF_DIALOGRC
screen_color = (white,black,off)
dialog_color = (white,black,off)
title_color = (cyan,black,on)
border_color = dialog_color
shadow_color = (black,black,on)
button_inactive_color = dialog_color
button_key_inactive_color = dialog_color
button_label_inactive_color = dialog_color
button_active_color = (white,cyan,on)
button_key_active_color = button_active_color
button_label_active_color = (black,cyan,on)
tag_key_selected_color = (white,cyan,on)
item_selected_color = tag_key_selected_color
form_text_color = (BLUE,black,ON)
form_item_readonly_color = (green,black,on)
itemhelp_color = (white,cyan,off)
inputbox_color = dialog_color
inputbox_border_color = dialog_color
searchbox_color = dialog_color
searchbox_title_color = title_color
searchbox_border_color = border_color
position_indicator_color = title_color
menubox_color = dialog_color
menubox_border_color = border_color
item_color = dialog_color
tag_color = title_color
tag_selected_color = button_label_active_color
tag_key_color = button_key_inactive_color
check_color = dialog_color
check_selected_color = button_active_color
uarrow_color = screen_color
darrow_color = screen_color
form_active_text_color = button_active_color
gauge_color = title_color
border2_color = dialog_color
searchbox_border2_color = dialog_color
menubox_border2_color = dialog_color
separate_widget = ''
tab_len = 0
visit_items = off
use_shadow = off
use_colors = on
EOF_DIALOGRC
  export DIALOGRC="$dialogRcFile"
}

# Testa se o terminal suporta caracteres gr√°ficos estendidos
sh_ascii_lines() {
  #Isso for√ßa o dialog a usar caracteres ASCII b√°sicos para as bordas.
  #if [[ "$LANG" =~ 'UTF-8' ]]; then
  if [[ "$(printf '\u250C')" =~ "‚îå" ]]; then
    export NCURSES_NO_UTF8_ACS=1  # Terminal suporta ACS
  else
    export NCURSES_NO_UTF8_ACS=0  # Terminal N√ÉO suporta ACS
  fi
  }

sh_setEnvironment() {
  [[ ! -e "$dialogRcFile" ]] && sh_create_dialogrc
  sh_ascii_lines
}

#!/bin/bash

# Definir as cores
VERDE='\033[0;32m'
AMARELO='\033[1;33m'
VERMELHO='\033[0;31m'
AZUL='\033[0;34m'
RESET='\033[0m' # Resetar a cor para o padr√£o

# Fun√ß√£o para exibir a ajuda
exibir_ajuda() {
  echo -e "${AMARELO}Uso: $0 [op√ß√µes]${RESET}"
  echo -e "${AMARELO}Ex : $0 --disk /dev/sdX --part 2 --label CHILI --dir CHILI${RESET}"
  echo
  echo -e "${AMARELO}Op√ß√µes:${RESET}"
  echo -e "  --disk <dispositivo>    Disco onde est√° a parti√ß√£o EFI (ex: /dev/nvme0n1)"
  echo -e "  --part <parti√ß√£o>       Parti√ß√£o EFI (ex: 2)"
  echo -e "  --label <nome>          Nome para a entrada EFI (ex: MEU-LINUX)"
  echo -e "  --dir <diret√≥rio>       Diret√≥rio dentro de /EFI/ onde o GRUB ser√° instalado (ex: MEU-LINUX)"
  echo -e "  --help                  Exibe esta ajuda${RESET}"
  exit 1
}

# Fun√ß√£o para verificar se o sistema foi inicializado em modo UEFI
verificar_uefi() {
  if [[ ! -d /sys/firmware/efi ]]; then
    echo -e "${VERMELHO}üö´ O sistema n√£o foi iniciado em modo UEFI!${RESET}"
    exit 1
  fi
}

# Fun√ß√£o para analisar os argumentos
while [[ $# -gt 0 ]]; do
  case "$1" in
    --disk)
      DISCO="$2"
      shift 2
      ;;
    --part)
      PARTICAO="$2"
      shift 2
      ;;
    --label)
      LABEL="$2"
      shift 2
      ;;
    --dir)
      DIRETORIO="$2"
      shift 2
      ;;
    --help)
      exibir_ajuda
      ;;
    *)
      echo -e "${VERMELHO}Op√ß√£o inv√°lida: $1${RESET}"
      exibir_ajuda
      ;;
  esac
done

# Validar se todos os par√¢metros obrigat√≥rios foram passados
if [[ -z "$DISCO" || -z "$PARTICAO" || -z "$LABEL" || -z "$DIRETORIO" ]]; then
  echo -e "${VERMELHO}üö´ Todos os par√¢metros --disk, --part, --label e --dir s√£o obrigat√≥rios!${RESET}"
  exibir_ajuda
fi

# === Validar se √© root ===
if [[ $EUID -ne 0 ]]; then
  echo -e "${VERMELHO}üö´ Rode como root!${RESET}"
  exit 1
fi

# === Verificar se o sistema foi inicializado em modo UEFI ===
verificar_uefi

# === Verificar se o disco informado existe ===
if [[ ! -b "$DISCO" ]]; then
  echo -e "${VERMELHO}üö´ O disco $DISCO n√£o foi encontrado!${RESET}"
  exit 1
fi

# === Verificar se a parti√ß√£o EFI existe (considerando parti√ß√µes com ou sem o sufixo 'p') ===
if [[ ! -b "${DISCO}${PARTICAO}" && ! -b "${DISCO}p$PARTICAO" ]]; then
  echo -e "${VERMELHO}üö´ A parti√ß√£o $PARTICAO no disco $DISCO n√£o foi encontrada!${RESET}"
  exit 1
fi

# === Criar um diret√≥rio tempor√°rio para montagem da parti√ß√£o EFI ===
MONTAGEM_TEMP="/mnt/efi"
echo -e "${AZUL}üîß Criando diret√≥rio tempor√°rio para montagem: $MONTAGEM_TEMP${RESET}"
mkdir -p "$MONTAGEM_TEMP"

# === Montar a parti√ß√£o EFI no diret√≥rio tempor√°rio ===
if [[ -b "${DISCO}${PARTICAO}" ]]; then
  echo -e "${AZUL}üîß Montando a parti√ß√£o ${DISCO}${PARTICAO} em $MONTAGEM_TEMP${RESET}"
  mount "${DISCO}${PARTICAO}" "$MONTAGEM_TEMP"
elif [[ -b "${DISCO}p$PARTICAO" ]]; then
  echo -e "${AZUL}üîß Montando a parti√ß√£o ${DISCO}p$PARTICAO em $MONTAGEM_TEMP${RESET}"
  mount "${DISCO}p$PARTICAO" "$MONTAGEM_TEMP"
fi

# Verificar se a montagem foi bem-sucedida
if [[ $? -ne 0 ]]; then
  echo -e "${VERMELHO}üö´ N√£o foi poss√≠vel montar a parti√ß√£o EFI!${RESET}"
  exit 1
fi

# === Criar o diret√≥rio onde o GRUB ser√° instalado ===
echo -e "${AZUL}üîß Criando diret√≥rio $MONTAGEM_TEMP/EFI/$DIRETORIO para o GRUB...${RESET}"
mkdir -p "$MONTAGEM_TEMP/EFI/$DIRETORIO"

# === Instalar o GRUB na pasta escolhida ===
echo -e "${AMARELO}üîß Instalando GRUB no diret√≥rio $MONTAGEM_TEMP/EFI/$DIRETORIO...${RESET}"
grub-install \
  --target=x86_64-efi \
  --efi-directory="$MONTAGEM_TEMP" \
  --bootloader-id="$DIRETORIO" \
  --recheck \
  --root-directory="$MONTAGEM_TEMP"

# === Criar a entrada UEFI com efibootmgr ===
echo -e "${AMARELO}üîß Criando a entrada UEFI com o efibootmgr...${RESET}"
efibootmgr \
  --create \
  --disk "$DISCO" \
  --part "$PARTICAO" \
  --label "$LABEL" \
  --loader "\\EFI\\$DIRETORIO\\grubx64.efi"

echo -e "${VERDE}‚úÖ Entrada '$LABEL' criada com sucesso!${RESET}"

# === Desmontar a parti√ß√£o EFI ap√≥s a instala√ß√£o ===
echo -e "${AZUL}üîß Desmontando a parti√ß√£o EFI...${RESET}"
umount "$MONTAGEM_TEMP"

# Remover o diret√≥rio tempor√°rio de montagem
echo -e "${AZUL}üîß Removendo o diret√≥rio tempor√°rio de montagem...${RESET}"
rmdir "$MONTAGEM_TEMP"

