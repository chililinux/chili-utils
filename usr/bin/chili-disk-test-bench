#!/usr/bin/env bash
# -*- coding: utf-8 -*-
# shellcheck shell=bash disable=SC1091,SC2039,SC2166
#
#  chili-disk-test-bench
#  Benchmark de leitura não destrutivo: dd, hdparm e fio
#  Created: 2025/09/18 - 21:29
#  Altered: qui 25 set 2025 12:08:22 -04
#
#  Copyright (c) 2025-2025, Vilmar Catafesta <vcatafesta@gmail.com>
#  All rights reserved.
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions
#  are met:
#  1. Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
#  THIS SOFTWARE IS PROVIDED BY Vilmar Catafesta ''AS IS'' AND ANY EXPRESS OR
#  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
#  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
#  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
#  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
#  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
##############################################################################
#export LANGUAGE=pt_BR
export TEXTDOMAINDIR=/usr/share/locale
export TEXTDOMAIN=chili-disk-test-bench

#debug
export PS4='${red}${0##*/}${green}[$FUNCNAME]${pink}[$LINENO]${reset}'
#set -x
#set -e
shopt -s extglob

#system
declare APP="${0##*/}"
declare _VERSION_="1.0.0-$(date +'%Y%m%d')"
declare APPDESC="$APP - Wraper for tests with dd, hdparm and fio"
declare distro="$(uname -n)"
declare -a DEPENDENCIES=(dd hdparm fio tput)
declare -A PACKAGEDEP=([dd]=coreutils [hdparm]=hdparm [fio]=fio [tput]=ncurses)

#trap cleanup EXIT
MostraErro() { echo "erro: ${red}$1${reset} => comando: ${cyan}'$2'${reset} => result=${yellow}$3${reset}"; }
trap 'MostraErro "$APP[$FUNCNAME][$LINENO]" "$BASH_COMMAND" "$?"; exit 1' ERR

sh_check_terminal() {
	if [ ! -t 1 ]; then
		use_color=0
	fi
}

set_varcolors() {
	sh_check_terminal
	# does the terminal support true-color?
	if [[ -n "$(command -v "tput")" ]]; then
		#tput setaf 127 | cat -v  #capturar saida
		: "${RED=$(tput bold)$(tput setaf 196)}"
		: "${GREEN=$(tput bold)$(tput setaf 2)}"
		: "${YELLOW=$(tput bold)$(tput setaf 3)}"
		: "${BLUE=$(tput setaf 4)}"
		: "${PURPLE=$(tput setaf 125)}"
		: "${CYAN=$(tput setaf 6)}"
		: "${NC=$(tput sgr0)}"
		: "${RESET=$(tput sgr0)}"
		: "${BOLD=$(tput bold)}"
		: "${black=$(tput bold)$(tput setaf 0)}"
		: "${reverse=$(tput rev)}"
		: "${branca=${black}$(tput setab 7)}"

		: "${reset=$(tput sgr0)}"
		: "${rst=$(tput sgr0)}"
		: "${bold=$(tput bold)}"
		: "${underline=$(tput smul)}"
		: "${nounderline=$(tput rmul)}"
		: "${reverse=$(tput rev)}"

		: "${black=$(tput bold)$(tput setaf 0)}"
		: "${red=$(tput bold)$(tput setaf 196)}"
		: "${green=$(tput bold)$(tput setaf 2)}"
		: "${yellow=$(tput bold)$(tput setaf 3)}"
		: "${blue=$(tput setaf 27)}"
		: "${pink=$(tput setaf 5)}"
		: "${magenta=$(tput setaf 5)}"
		: "${cyan=$(tput setaf 6)}"
		: "${white=$(tput setaf 7)}"
		: "${gray=$(tput setaf 8)}"
		: "${light_red=$(tput setaf 9)}"
		: "${light_green=$(tput setaf 10)}"
		: "${light_yellow=$(tput setaf 11)}"
		: "${light_blue=$(tput setaf 12)}"
		: "${light_magenta=$(tput setaf 13)}"
		: "${light_cyan=$(tput setaf 14)}"
		: "${light_white=$(tput setaf 15)}"
		: "${orange=$(tput setaf 202)}"
		: "${purple=$(tput setaf 125)}"
		: "${violet=$(tput setaf 61)}"

		# Definir cores de fundo
		: "${preto=$(tput setab 0)}"
		: "${vermelho=$(tput setab 196)}"
		: "${verde=$(tput setab 2)}"
		: "${amarelo=$(tput setab 3)}"
		: "${azul=$(tput setab 20)}"
		: "${roxo=$(tput setab 5)}"
		: "${ciano=$(tput setab 6)}"
		: "${branca="${black}$(tput setab 7)"}"
		: "${cinza=$(tput setab 8)}"
		: "${laranja=$(tput setab 202)}"
		: "${roxa=$(tput setab 125)}"
		: "${violeta=$(tput setab 61)}"

		: "${COL_NC='\e[0m'}" # No Color
		: "${COL_LIGHT_GREEN='\e[1;32m'}"
		: "${COL_LIGHT_RED='\e[1;31m'}"
		: "${DONE="${COL_LIGHT_GREEN} done!${COL_NC}"}"
		: "${OVER="\\r\\033[K"}"
		: "${DOTPREFIX="  ${black}::${reset} "}"
		: "${TICK="${white}[${green}✓${rst}${white}]${rst}"}"
		: "${CROSS="${white}[${red}✗${rst}${white}]${rst}"}"
		: "${INFO="${white}[${yellow}i${rst}${white}]${rst}"}"
	else
		unset_varcolors
	fi
}

unset_varcolors() {
	unset RED GREEN YELLOW BLUE PURPLE CYAN NC RESET BOLD
	unset reset rst bold underline nounderline reverse
	unset black red green yellow blue magenta cyan white gray orange purple violet
	unset light_red light_green light_yellow light_blue light_magenta light_cyan light_white
	unset preto vermelho verde amarelo azul roxo ciano branca cinza laranja roxa violeta
	TICK="${white}[${verde}✓${rst}${white}]${rst}"
	CROSS="${white}[${roxa}✗${rst}${white}]${rst}"
	INFO="${white}[${cinza}i${rst}${white}]${rst}"
}

sh_checkroot() {
	if [[ "$(id -u)" != "0" ]]; then
		#alerta "$cdistro Linux installer" "${RED}${REVERSE}You should run this script as root!"
		#scrend 0
		elevate_to_root "$@"
	fi
}

elevate_to_root() {
	log_err "This script must be run as root."
	log_ok "Elevating privileges..."
	ccabec+='root [elevated]'
	# Tenta usar sudo primeiro (caso esteja configurado)
	if command -v sudo >/dev/null 2>&1; then
		exec sudo bash "$0" "$@"
	fi
	# Se sudo falhar, tenta su
	if command -v su >/dev/null 2>&1; then
		exec su -c "$0 $*"
	fi
	die "Error: Unable to elevate privileges. Run manually as root."
}

sh_checkDependencies() {
  local aBlock_files=()
  local d
  local errorFound=false
  declare -a missing

  for d in "${DEPENDENCIES[@]}"; do
    if ! command -v "$d" &>/dev/null; then
      log_err "${red}Error${reset}: $(gettext "Não foi possível encontrar o comando") ${cyan}'$d'${reset} -> $(gettext "instalar pacote") ${cyan}'"${PACKAGEDEP[$d]}"'${reset}"
      missing+=("$d")
      errorFound=true
    else
      log_msg "Check: ${cyan}$d"
    fi
  done

  if $errorFound; then
    replicate '='
    echo "${yellow}             $(gettext "IMPOSSÍVEL CONTINUAR")"
    echo "${black}$(gettext "Este script precisa dos comandos listados acima")"
    echo "${black}$(gettext "Instale-os e/ou verifique se eles estão em seu") ${red}\$PATH${reset}"
    replicate '='
    if readconf "Deseja instalar os pacotes necessários ?"; then
      msg_info "Tentando instalar necessários pacotes ${cyan}'${missing[@]}' ${reset}via pacman"
      if sudo pacman -Sy --needed --quiet --noconfirm "${PACKAGEDEP[@]}" 1>/dev/null; then
        sh_checkDependencies #overload
      else
        die "Encerrando..."
      fi
    else
      die "Encerrando..."
    fi
  fi

}

readconf() {
  local msg="$1"
  local color="${2:-${yellow}}"

  echo -n -e "$color"
  if [[ $LC_DEFAULT -eq 0 ]]; then
    read -r -p "$msg [S/n]"
  else
    read -r -p "$msg [Y/n]"
  fi
  echo -n -e "$reset"
  case "${REPLY^}" in
  [SY]) return 0 ;;
  "") return 0 ;;
  *) return 1 ;;
  esac
}

replicate() {
  local char=${1:-'#'}
  local nsize=${2:-$(tput cols)}
  local line
  printf -v line "%*s" "$nsize" && echo -e "${blue}${line// /$char}${reset}"
}
export -f replicate

msg_info() {
  local msg="$1"
  #local caller_function="${FUNCNAME[1]}" # Nome da função que chamou a função atual
  #local caller_line="${BASH_LINENO[1]}"  # Número da linha que chamou a função atual
  #msg="$(sed 's/<[^>]*>//g' <<<"$msg")"  # Remove as tags HTML
  #echo -e "${blue}==>${green}[${caller_function}:${caller_line}]=>${yellow}info   : ${cyan}${msg}${reset}"
  #echo -e "${caller_function}=>${yellow}info   : ${cyan}${msg}${reset}"
  #echo -e "==>${yellow}[INFO]   : ${cyan}${msg}${reset}"
  #printf "==>%b%-10s%s\n" "${yellow}" "[INFO]" "${cyan}$msg${reset}"
  printf "  %b %s\\n" "${INFO}" "${*}"

}
export -f msg_info

log_msg() {
  local retval="${PIPESTATUS[0]}"
  local pcount=$#

  ((pcount >= 2)) && {
    retval=$1
    shift
  }
  if [[ $retval -eq 0 ]]; then
    printf "  %b %s\\n" "${TICK}" "${*}"
  else
    printf "  %b %s\\n" "${CROSS}" "${*}"
  fi
}

log_ok() { echo -e "  ${TICK} ${*}${reset}"; }
log_err() { echo -e "  ${CROSS} ${*}${reset}"; }
die() {
	echo -e "  ${CROSS} ${red}${*}${reset}"
	exit 1
}

# configure ambiente
set_varcolors

DEVICES=("$@")
if [[ -z "${DEVICES[@]}" || "$@" == '-h' || "$@" == '--help'  ]]; then
	echo "${APPDESC}"
	die "Uso: $0 /dev/sdX [/dev/sdY] [...]"
	exit 1
fi

sh_checkroot "$@"
sh_checkDependencies

for DEVICE in "${DEVICES[@]}"; do
  if [[ ! -b "$DEVICE" ]]; then
    log_err "${red}Dispositivo inválido: [${DEVICE}]. Pulando...${reset}"
    continue
  fi
  replicate
	echo -e "${black}=== Testes de leitura para ${yellow}${DEVICE} ${black}===${reset}"

	##############################
	# Teste com dd
	##############################
	msg_info "${orange}--- dd (100 MB, bloco 1M) ---${reset}"
	DD_OUT=$(dd if="$DEVICE" of=/dev/null bs=1M count=100 iflag=direct status=progress 2>&1)
	if [ $? -eq 0 ]; then
		DD_SPEED=$(echo "$DD_OUT" | tail -n1 | awk -F', ' '{print $4}')
		log_ok "${green}dd concluído: ${DD_SPEED}${reset}"
		dd_result=$(log_ok "dd    : ($DD_SPEED)")
	else
		log_err "${red}dd falhou!${reset}"
		dd_result=$(log_err "dd    : falhou!")
	fi

	##############################
	# Teste com hdparm
	##############################
	msg_info "${orange}--- hdparm (buffered read) ---${reset}"
	HDPARM_OUT=$(hdparm -t "$DEVICE" 2>&1)
	if [ $? -eq 0 ]; then
		# Pega a linha que contém MB/sec
		HD_SPEED=$(echo "$HDPARM_OUT" | awk '/MB\/sec/ {print $11}')
		log_ok "${green}hdparm concluído: ${HD_SPEED} MB/s${reset}"
		hdparm_result=$(log_ok "hdparm: ($HD_SPEED MB/s)")
	else
		log_err "${red}hdparm falhou!${reset}"
		hdparm_result=$(log_err "hdparm: Falha")
	fi

	##############################
	# Teste com fio
	##############################
	msg_info "${orange}--- fio (100 MB, seq read) ---${reset}"
	FIO_OUT=$(fio --name=seqread --filename="$DEVICE" --rw=read --bs=1M --size=100M --direct=1 --runtime=10 --time_based --ioengine=libaio 2>&1)
	if [ $? -eq 0 ]; then
		FIO_SPEED=$(echo "$FIO_OUT" | grep -oP 'BW=.*?\(\K[0-9.]+[KMG]B/s')
		log_ok "${green}fio concluído: $FIO_SPEED${reset}"
		fio_result=$(log_ok "fio   : ($FIO_SPEED)")
	else
		log_err "${red}fio falhou!${reset}"
		fio_result=$(log_err "fio   : falhou!")
	fi

	##############################
	# Resumo
	##############################
	echo -e "${yellow}=== Resumo de velocidades ===${reset}"
	echo -e "$dd_result"
	echo -e "$hdparm_result"
	echo -e "$fio_result"
done
