#!/usr/bin/env bash
#shellcheck disable=SC2155,SC2034
#shellcheck source=/dev/null
#
#  chili-maketar - Create tar of directories or files
#
#  Created: 2023/07/28
#  Altered: 2023/07/28
#  Updated: qui 13 nov 2025 23:34:04 -04
#
#  Copyright (c) 2023-2025, Vilmar Catafesta <vcatafesta@gmail.com>
#  All rights reserved.
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions
#  are met:
#  1. Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
#  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
#  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
#  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
#  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
#  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
#  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
##########################################################################
# =========================================================
# Cores e terminal
# =========================================================
: "${RED=$(tput bold)$(tput setaf 196)}"
: "${GREEN=$(tput bold)$(tput setaf 2)}"
: "${YELLOW=$(tput bold)$(tput setaf 3)}"
: "${BLUE=$(tput setaf 4)}"
: "${PURPLE=$(tput setaf 125)}"
: "${CYAN=$(tput setaf 6)}"
: "${NC=$(tput sgr0)}"
: "${RESET=$(tput sgr0)}"
: "${BOLD=$(tput bold)}"
: "${black=$(tput bold)$(tput setaf 0)}"
: "${reverse=$(tput rev)}"
: "${branca=${black}$(tput setab 7)}"

: "${reset=$(tput sgr0)}"
: "${rst=$(tput sgr0)}"
: "${bold=$(tput bold)}"
: "${underline=$(tput smul)}"
: "${nounderline=$(tput rmul)}"
: "${reverse=$(tput rev)}"

: "${black=$(tput bold)$(tput setaf 0)}"
: "${red=$(tput bold)$(tput setaf 196)}"
: "${green=$(tput bold)$(tput setaf 2)}"
: "${yellow=$(tput bold)$(tput setaf 3)}"
: "${blue=$(tput setaf 27)}"
: "${pink=$(tput setaf 5)}"
: "${magenta=$(tput setaf 5)}"
: "${cyan=$(tput setaf 6)}"
: "${white=$(tput setaf 7)}"
: "${gray=$(tput setaf 8)}"
: "${light_red=$(tput setaf 9)}"
: "${light_green=$(tput setaf 10)}"
: "${light_yellow=$(tput setaf 11)}"
: "${light_blue=$(tput setaf 12)}"
: "${light_magenta=$(tput setaf 13)}"
: "${light_cyan=$(tput setaf 14)}"
: "${light_white=$(tput setaf 15)}"
: "${orange=$(tput setaf 202)}"
: "${purple=$(tput setaf 125)}"
: "${violet=$(tput setaf 61)}"

# Definir cores de fundo
: "${preto=$(tput setab 0)}"
: "${vermelho=$(tput setab 196)}"
: "${verde=$(tput setab 2)}"
: "${amarelo=$(tput setab 3)}"
: "${azul=$(tput setab 20)}"
: "${roxo=$(tput setab 5)}"
: "${ciano=$(tput setab 6)}"
: "${branca="${black}$(tput setab 7)"}"
: "${cinza=$(tput setab 8)}"
: "${laranja=$(tput setab 202)}"
: "${roxa=$(tput setab 125)}"
: "${violeta=$(tput setab 61)}"

: "${COL_NC='\e[0m'}" # No Color
: "${COL_LIGHT_GREEN='\e[1;32m'}"
: "${COL_LIGHT_RED='\e[1;31m'}"
: "${DONE="${COL_LIGHT_GREEN} done!${COL_NC}"}"
: "${OVER="\\r\\033[K"}"
: "${DOTPREFIX="  ${black}::${reset} "}"
: "${clrkey=${light_white}}"
: "${TICK="${clrkey}[${green}✓✓✓${clrkey}]${rst}"}"
: "${CROSS="${clrkey}[${red}✗✗✗${clrkey}]${rst}"}"
: "${MID="${clrkey}[${red}✗✗${green}✓${clrkey}]${rst}"}"
: "${WARN="${clrkey}[${yellow}⚠  ${clrkey}]${yellow}"}"
: "${INFO="${clrkey}[${yellow}➡  ${clrkey}]${rst}"}"

export PS4='${red}${0##*/}${green}[$FUNCNAME]${pink}[$LINENO]${reset}'
#set -euo pipefail
shopt -s extglob

readonly APP="${0##*/}"
readonly APPDESC="Create tar of directories or files"
readonly _VERSION_="3.3.5-20251113"

# Dependências base
declare DEPENDENCIES=(tar tput sed)
declare PACKAGEDEP=(tar ncurses sed)

# Mapeamento de compressores → comandos/pacotes (Arch Linux)
declare -A COMPRESS_DEPS=(
	[pigz]="pigz pigz"
	[pzstd]="zstd zstd"
	[gzip]="gzip gzip"
	[xz]="xz xz"
	[lz4]="lz4 lz4"
	[lzo]="lzop lzop"
	[br]="brotli brotli"
	[lrzip]="lrzip lrzip"
	[zpaq]="zpaq zpaq"
	[zstdgpg]="zstd gpg"
	[7z]="7z p7zip"
	[zip]="zip zip"
	[tarzstgpg2]="zstd gpg2"
)

# =========================================================
# Utilitários básicos
# =========================================================

function sh_diahora() {
	date +"%d%m%Y-%H%M%S"
}

function sh_config {
	declare -g BOOTLOG="/tmp/${APP}_$(date +'%Y%m%d_%H%M%S')_${USER}.log"
	if [[ -w /dev/tty ]]; then
		declare -g LOGGER='/dev/tty'
	else
		declare -g LOGGER='/dev/stdout'
	fi
	declare -g quiet=true
	declare -g use_color=true
	declare -g compressor="pzstd"
	declare -gi ncontador=1
	declare -gi njobs=0
}

# =========================================================
# Funções auxiliares
# =========================================================

function add_compressor_dep() {
	DEPENDENCIES+=("$1")
	PACKAGEDEP+=("$2")
}

print_size() {
	size=$(du -h "$filename" 2>/dev/null | cut -f1)
	log_ok "Successfully created: ${red}$filename${reset} (${cyan}${size:-0}${reset})"
}

function cmdlogger() {
	local cmd=("$@")
	print_summary
	info_msg "Executando comando : ${cyan}${cmd[*]}${reset}"
	"${cmd[@]}" 2>&1 | tee -a "$BOOTLOG"
	local status=${PIPESTATUS[0]}
	if ((status > 1)); then
		die "Erro durante execução: ${cmd[*]}"
	elif ((status == 1)); then
		log_warn "Avisos ignoráveis: ${cmd[*]}"
	fi
}

# =========================================================
#  Mensagens
# =========================================================

die() {
	((++njobs))
	printf "${red}$CROSS ${pink}%03d/%03d => ${red}FATAL: %s\n\033[m" "$ncontador" "$njobs" "$*"
	((++ncontador))
	exit 1
}

info_msg() {
	((++njobs))
	printf "${green}$INFO ${pink}%03d/%03d => ${yellow}%s\n\033[m" "$ncontador" "$njobs" "$*"
	((++ncontador))
}

log_error() { printf "%30s:%-06d] : %s => %s\n" "$1" "$2" "$3 $4" >>"$BOOTLOG"; }
msg() { echo -e "${INFO} ${*}${reset}"; }
log_ok() { echo -e "${TICK} ${*}${reset}"; }
log_err() { echo -e "${CROSS} ${*}${reset}"; }
log_mid() { echo -e "${MID} ${*}${reset}"; }
log_warn() { echo -e "${WARN} ${*}${reset}"; }
msg_tab() { echo -e "  ${INFO} ${*}${reset}"; }
log_ok_tab() { echo -e "  ${TICK} ${*}${reset}"; }
log_err_tab() { echo -e "  ${CROSS} ${*}${reset}"; }
log_mid_tab() { echo -e "  ${MID} ${*}${reset}"; }
log_warn_tab() { echo -e "  ${WARN} ${*}${reset}"; }

function print_summary() {
	info_msg "Compressor final   : ${cyan}$(awk '{print $1}' <<<"${COMPRESS_DEPS[$compressor]}")${reset}"
	info_msg "Arquivo de saída   : ${cyan}$filename${reset}"
	info_msg "Itens para arquivar: ${cyan}${ITEMS[*]}${reset}"
}

# =========================================================
# Dependências
# =========================================================

function sh_checkDependencies() {
	local missing=()

	# Verifica dependências básicas
	for d in "${DEPENDENCIES[@]}"; do
		if ! command -v "$d" &>/dev/null; then
			missing+=("$d")
			info_msg "${red}ERRO:${reset} comando ausente: ${cyan}'$d'${reset}"
		fi
	done

	if ((${#missing[@]})); then
		info_msg "Tentando instalar dependências básicas: ${yellow}${missing[*]}${reset}"
		sudo pacman -Sy "${PACKAGEDEP[@]}" --needed --noconfirm &>/dev/null ||
			die "Falha ao instalar dependências básicas: ${missing[*]}"
	fi

	# Instala apenas o compressor selecionado
	local cdep="${COMPRESS_DEPS[$compressor]}"
	if [[ -n "$cdep" ]]; then
		read -r cmd pkg <<<"$cdep"
		if ! command -v "$cmd" &>/dev/null; then
			info_msg "Instalando pacote necessário para ${yellow}$compressor${reset}: ${cyan}$pkg${reset}"
			sudo pacman -Sy "$pkg" --needed --noconfirm &>/dev/null ||
				die "Falha ao instalar pacote: ${pkg} (necessário para $compressor)"
		fi
	fi
}

# =========================================================
# Compactação
# =========================================================

function sh_main {
  #Sim, parece esquisito. #Mas os dois têm funções diferentes — e ambas são úteis aqui.
  #OK, mas não dá confusão ter duas variáveis com o mesmo nome? #NÃO! Porque:
  # - Dentro da função, quando você escreve filename, o Bash sempre usa a local.
  # - Fora da função, quando você escreve filename, o Bash usa a global.
  #Ou seja: Elas não se misturam — mesmo com o mesmo nome.
  local filename="$1"
  declare -g filename="$1"   # <-- aqui mesmo
	shift
	local exclude_opt=""
	local sources=("$@")
	local error param='--verbose'

	#  Evita adicionar ".tar" para compressores que não usam tar
	# Evita adicionar .tar desnecessariamente
	if [[ ! "$compressor" =~ ^(zip|7z|zpaq)$ ]]; then
		if [[ ! "$filename" =~ \.tar(\.|$) ]]; then
			filename+='.tar'
		fi
	fi

	#	filename="${filename#./}"
	#	filename="${filename/#./}"
	# Remove apenas "./", mas preserva nomes que começam com "."
	[[ "$filename" == ./* ]] && filename="${filename#./}"

	exclude_opt="--exclude=$(basename "$filename")*"
	$quiet && param=''

	case "$compressor" in
	7z)
		[[ "$filename" != *.7z ]] && filename+=".7z"
		print_summary
		add_compressor_dep 7z p7zip
		info_msg "Usando 7z (alta compressão e suporte a múltiplos formatos)"
		if $quiet; then
			7z a "$filename" "${sources[@]}" >/dev/null 2>&1
		else
			cmdlogger 7z a "$filename" "${sources[@]}"
		fi
		local size
		size=$(du -h "$filename" 2>/dev/null | cut -f1)
		info_msg "Successfully created: ${red}$filename${reset} (${cyan}${size:-0}${reset})"
		return 0
		;;
	zip)
		[[ "$filename" != *.zip ]] && filename+=".zip"
		print_summary
		add_compressor_dep zip zip
		info_msg "Usando zip tradicional"
		if $quiet; then
			zip -r "$filename" "${sources[@]}" >/dev/null 2>&1
		else
			cmdlogger zip -r "$filename" "${sources[@]}"
		fi
		local size
		size=$(du -h "$filename" 2>/dev/null | cut -f1)
		info_msg "Successfully created: ${red}$filename${reset} (${cyan}${size:-0}${reset})"
		return 0
		;;
	tarzstgpg2)
		# Garante que a extensão não será duplicada
		filename="${filename%.tar}.tar.zst.gpg"
		add_compressor_dep zstd zstd
		add_compressor_dep gpg gnupg
		info_msg "Compactando com zstd e criptografando com gpg (modo seguro)"

		if $quiet; then
			tar --posix --xattrs -cf - "${sources[@]}" | zstd -T0 -19 | gpg -c -o "$filename" >/dev/null 2>&1
		else
			info_msg "Executando comando: tar --posix --xattrs -cf - ... | zstd -T0 -19 | gpg -c -o ${cyan}$filename${reset}"
			tar --posix --xattrs -cf - "${sources[@]}" | zstd -T0 -19 | gpg -c -o "$filename"
		fi
		print_size
		return 0
		;;
	pigz)
		filename+=".gz"
		cmd=(tar "$exclude_opt" -I pigz)
		;;
	pzstd)
		filename+=".zst"
		cmd=(tar "$exclude_opt" -I pzstd)
		;;
	gzip)
		filename+=".gz"
		cmd=(tar "$exclude_opt" -z)
		;;
	xz)
		filename+=".xz"
		cmd=(tar "$exclude_opt" --xz)
		;;
	lz4)
		filename+=".lz4"
		cmd=(tar "$exclude_opt" -I lz4)
		;;
	lzo)
		filename+=".lzo"
		cmd=(tar "$exclude_opt" -I lzop)
		;;
	br)
		filename+=".br"
		cmd=(tar "$exclude_opt" -I "brotli -q 11")
		;;
	lrzip)
		[[ "$filename" != *.lrz ]] && filename+=".lrz"
		add_compressor_dep lrzip lrzip
		info_msg "Usando lrzip (ótimo para arquivos grandes)"
		if $quiet; then
			tar $exclude_opt -I lrzip --posix --xattrs -chf "$filename" "${sources[@]}" >/dev/null 2>&1
		else
			cmdlogger tar $exclude_opt -I lrzip --posix --xattrs -chf "$filename" "${sources[@]}"
		fi
		print_size
		return 0
		;;
	zpaq)
		# =========================================================
		# ZPAQ — compressão extrema (pós-processo)
		# =========================================================
		[[ "$filename" != *.zpaq ]] && filename+=".zpaq"
		add_compressor_dep zpaq zpaq
		info_msg "Usando método compatível de compactação com zpaq (modo pós-processo)"

		# Remove .zpaq temporariamente pra gerar o tar intermediário
		local tmpfile="${filename%.zpaq}.tar"

		if $quiet; then
			tar --posix --xattrs -chf "$tmpfile" "${sources[@]}" >/dev/null 2>&1
			zpaq a "$filename" "$tmpfile" -method 3 -threads 0 >/dev/null 2>&1
		else
			cmdlogger tar --posix --xattrs -chf "$tmpfile" "${sources[@]}"
			cmdlogger zpaq a "$filename" "$tmpfile" -method 3 -threads 0
		fi
		rm -f "$tmpfile"
		local size
		size=$(du -h "$filename" 2>/dev/null | cut -f1)
		info_msg "Successfully created: ${red}$filename${reset} (${cyan}${size:-0}${reset})"
		return 0
		;;
	zstdgpg)
		filename+=".zst.gpg"
		cmd=(tar "$exclude_opt" -I 'bash -c "zstd -T0 -19 | gpg -c"')
		;;
	*) cmd=(tar "$exclude_opt") ;;
	esac

	if [[ "$compressor" != "zpaq" ]]; then
		#		cmdlogger "${cmd[@]}" ${param:+$param} --posix --xattrs -chf "$filename" "${sources[@]}"
		cmdlogger "${cmd[@]}" ${param:+$param} --ignore-failed-read --warning=no-file-changed --warning=no-file-removed --posix --xattrs -chf "$filename" "${sources[@]}"
	fi
	print_size
}

# =========================================================
# Ajuda
# =========================================================

function sh_usage() {
	cat <<-EOF
		${yellow}$APP${reset} - ${green}$APPDESC${reset}  (${cyan}v$_VERSION_${reset})
		${bold}${pink}Compactadores disponíveis:${reset}
		  ${yellow}-7${reset}  7z (p7zip, compressão forte)
		  ${yellow}-b${reset}  brotli (para web)
		  ${yellow}-e${reset}  zstd+gpg (criptografado)
		  ${yellow}-g${reset}  gzip (simples)
		  ${yellow}-l${reset}  lz4 (ultrarrápido)
		  ${yellow}-o${reset}  lzop (leve)
		  ${yellow}-p${reset}  zstd + gpg2 (criptografia com senha)
		  ${yellow}-q${reset}  zpaq (compressão extrema)
		  ${yellow}-r${reset}  lrzip (ótimo para arquivos grandes)
		  ${yellow}-s${reset}  pzstd (Zstandard, ${cyan}padrão${reset})
		  ${yellow}-x${reset}  xz (alta compressão)
		  ${yellow}-z${reset}  pigz (gzip paralelo)
		  ${yellow}-Z${reset}  zip (simples e universal)
		  ${yellow}-v|--verbose${reset}  modo verbose
		  ${yellow}-h${reset}  este help
		${bold}${pink}Exemplos:${reset}
				  ${cyan}$APP -s${reset}                  → compacta diretório atual
				  ${cyan}$APP -l /etc${reset}             → usa lz4
				  ${cyan}$APP -b site assets.br${reset}   → usa brotli
				  ${cyan}$APP -q${reset}                  → compacta via zpaq (modo pós-processo)
				  ${cyan}$APP -e backup${reset}           → compacta e criptografa
				  ${cyan}$APP *.c *.h fontes.tar${reset}  → compacta com zstd (padrao)
				  ${cyan}$APP .                 ${reset}  → compacta com zstd (padrao)
				${bold}${cyan}──────────────────────────────────────────────${reset}
				 ${yellow}Autor:${reset} ${green}Vilmar Catafesta${reset}  ${cyan}<vcatafesta@gmail.com>${reset}
				${bold}${cyan}──────────────────────────────────────────────${reset}
	EOF
	exit 1
}

# =========================================================
# Execução principal
# =========================================================

sh_config

[[ $# -eq 0 || $1 =~ ^(-h|--help|help|-help)$ ]] && sh_usage

if test -w "$PWD"; then
	info_msg "$USER com gravação permitida em $PWD, prosseguindo..."
else
	info_msg "$USER sem permissão de gravação em $PWD"
	if [ "$(id -u)" -ne 0 ]; then
		die "$APP: need root perms to continue, exiting."
	fi
fi

# Suporte a opções longas
for arg in "$@"; do
	case "$arg" in
	--verbose) set -- "${@/--verbose/-v}" ;;
	esac
done

while getopts "vnzsgxlobrqe7pZ" opt; do
	case $opt in
	7) compressor="7z" ;;
	p) compressor="tarzstgpg2" ;;
	v) quiet=false ;;
	n) use_color=false ;;
	z) compressor="pigz" ;;
	s) compressor="pzstd" ;;
	g) compressor="gzip" ;;
	x) compressor="xz" ;;
	l) compressor="lz4" ;;
	o) compressor="lzo" ;;
	b) compressor="br" ;;
	r) compressor="lrzip" ;;
	q) compressor="zpaq" ;;
	e) compressor="zstdgpg" ;;
	Z) compressor="zip" ;;
	\?) die "Invalid option: -$OPTARG" ;;
	esac
done
shift $((OPTIND - 1))

# Se nenhum argumento for passado...
[[ $# -eq 0 ]] && {
  # ...mostra mensagem dizendo que vai usar o diretório atual
  info_msg "Nenhum arquivo/diretório informado — usando diretório atual."
  # ...e substitui os argumentos por "."
  # Ou seja: o script passa a se comportar como se você tivesse digitado:
  # chili-maketar .
  set -- .
}

# Se o último argumento não é arquivo/diretório, então é o nome de saída
lastarg="${!#}"
if [[ ! -e "$lastarg" ]]; then
	outfile="$lastarg"
	set -- "${@:1:$(($# - 1))}"
else
	outfile=""
fi

declare -a ITEMS=()
for item in "$@"; do
	for i in $item; do [[ -e "$i" ]] && ITEMS+=("$i"); done
done
[[ ${#ITEMS[@]} -eq 0 ]] && die "Nenhum arquivo/diretório encontrado."

# Nome lógico do arquivo de saída
# Nome lógico do arquivo de saída
# Nome lógico do arquivo de saída
if [[ -z "$outfile" ]]; then
  if ((${#ITEMS[@]} == 1)); then
    item="${ITEMS[0]}"

    # Caso especial: "."
    if [[ "$item" == "." ]]; then
      localname=$(basename "$PWD")

    # Diretório → pega basename correto mesmo com caminhos absolutos
    elif [[ -d "$item" ]]; then
      localname=$(basename -- "$item")

    # Arquivo
    elif [[ -f "$item" ]]; then
      base=$(basename -- "$item")
      if [[ "$base" =~ ^\..* ]]; then
        localname="$base"      # Mantém .bashrc
      else
        localname="${base%%.*}"
      fi
    fi

  else
    localname=$(basename "$PWD")
  fi

  case "$compressor" in
    zip)  outfile="${localname}-$(sh_diahora).zip"  ;;
    7z)   outfile="${localname}-$(sh_diahora).7z"   ;;
    zpaq) outfile="${localname}-$(sh_diahora).zpaq" ;;
    *)    outfile="${localname}-$(sh_diahora).tar"  ;;
  esac
fi

if [[ "${ITEMS[*]}" == "." ]]; then
	shopt -s dotglob nullglob
	ITEMS=(*)
	shopt -u dotglob nullglob
	# Se ainda estiver vazio, força incluir '.'
	[[ ${#ITEMS[@]} -eq 0 ]] && ITEMS=(.)
fi

sh_checkDependencies
sh_main "$outfile" "${ITEMS[@]}"
