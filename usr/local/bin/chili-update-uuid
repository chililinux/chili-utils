#!/usr/bin/env bash
# -*- coding: utf-8 -*-
# shellcheck shell=bash disable=SC1091,SC2039,SC2166
#
#  chili-update-uuid
#  Wrapper para atualizar UUIDs de imagens ou discos e ajustar fstab/grub.cfg
#  Atualiza /etc/fstab e grub.cfg
#  Uso: chili-update-uuid imagem.img
#
#  Created: 2025/09/10 - 12:49
#  Altered: seg 29 set 2025 00:07:41 -04
#  Updated: seg 06 out 2025 21:48:38 -04
#
#  Copyright (c) 2025-2025, Vilmar Catafesta <vcatafesta@gmail.com>
#  All rights reserved.
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions
#  are met:
#  1. Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
#  THIS SOFTWARE IS PROVIDED BY Vilmar Catafesta ''AS IS'' AND ANY EXPRESS OR
#  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
#  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
#  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
#  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
#  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
##############################################################################
#export LANGUAGE=pt_BR
export TEXTDOMAINDIR=/usr/share/locale
export TEXTDOMAIN=chili-update-uuid

#debug
export PS4='${red}${0##*/}${green}[$FUNCNAME]${pink}[$LINENO]${reset}'
#set -x
set -e
shopt -s extglob

#system
declare APP="${0##*/}"
declare _VERSION_="1.0.0-$(date +'%Y%m%d')"
declare APPDESC="$APP - Wrapper para atualizar UUIDs de imagens ou discos e ajustar fstab/grub.cfg"
declare distro="$(uname -n)"
declare DEPENDENCIES=(tput)

MostraErro() { echo "erro: ${red}$1${reset} => comando: ${cyan}'$2'${reset} => result=${yellow}$3${reset}"; }
#trap 'MostraErro "$APP[$FUNCNAME][$LINENO]" "$BASH_COMMAND" "$?"; exit 1' ERR
cleanup() {
	if [[ -n "$LOOP" ]]; then
    if mount | grep -q "$LOOP"; then
      msg "Liberando loop device..."
      run_cmd "losetup -d $LOOP" 2>/dev/null || true
    fi
  fi
}
trap cleanup EXIT ERR

set_varcolors() {
	# does the terminal support true-color?
	if [[ -n "$(command -v "tput")" ]]; then
		#tput setaf 127 | cat -v  #capturar saida
		: "${RED=$(tput bold)$(tput setaf 196)}"
		: "${GREEN=$(tput bold)$(tput setaf 2)}"
		: "${YELLOW=$(tput bold)$(tput setaf 3)}"
		: "${BLUE=$(tput setaf 4)}"
		: "${PURPLE=$(tput setaf 125)}"
		: "${CYAN=$(tput setaf 6)}"
		: "${NC=$(tput sgr0)}"
		: "${RESET=$(tput sgr0)}"
		: "${BOLD=$(tput bold)}"
		: "${black=$(tput bold)$(tput setaf 0)}"
		: "${reverse=$(tput rev)}"
		: "${branca=${black}$(tput setab 7)}"

		: "${reset=$(tput sgr0)}"
		: "${rst=$(tput sgr0)}"
		: "${bold=$(tput bold)}"
		: "${underline=$(tput smul)}"
		: "${nounderline=$(tput rmul)}"
		: "${reverse=$(tput rev)}"

		: "${black=$(tput bold)$(tput setaf 0)}"
		: "${red=$(tput bold)$(tput setaf 196)}"
		: "${green=$(tput bold)$(tput setaf 2)}"
		: "${yellow=$(tput bold)$(tput setaf 3)}"
		: "${blue=$(tput setaf 27)}"
		: "${pink=$(tput setaf 5)}"
		: "${magenta=$(tput setaf 5)}"
		: "${cyan=$(tput setaf 6)}"
		: "${white=$(tput setaf 7)}"
		: "${gray=$(tput setaf 8)}"
		: "${light_red=$(tput setaf 9)}"
		: "${light_green=$(tput setaf 10)}"
		: "${light_yellow=$(tput setaf 11)}"
		: "${light_blue=$(tput setaf 12)}"
		: "${light_magenta=$(tput setaf 13)}"
		: "${light_cyan=$(tput setaf 14)}"
		: "${light_white=$(tput setaf 15)}"
		: "${orange=$(tput setaf 202)}"
		: "${purple=$(tput setaf 125)}"
		: "${violet=$(tput setaf 61)}"

		# Definir cores de fundo
		: "${preto=$(tput setab 0)}"
		: "${vermelho=$(tput setab 196)}"
		: "${verde=$(tput setab 2)}"
		: "${amarelo=$(tput setab 3)}"
		: "${azul=$(tput setab 20)}"
		: "${roxo=$(tput setab 5)}"
		: "${ciano=$(tput setab 6)}"
		: "${branca="${black}$(tput setab 7)"}"
		: "${cinza=$(tput setab 8)}"
		: "${laranja=$(tput setab 202)}"
		: "${roxa=$(tput setab 125)}"
		: "${violeta=$(tput setab 61)}"

    : "${COL_NC='\e[0m'}" # No Color
    : "${COL_LIGHT_GREEN='\e[1;32m'}"
    : "${COL_LIGHT_RED='\e[1;31m'}"
    : "${DONE="${COL_LIGHT_GREEN} done!${COL_NC}"}"
    : "${OVER="\\r\\033[K"}"
    : "${DOTPREFIX="  ${black}::${reset} "}"
    : "${clrkey=${light_white}}"
    : "${TICK="${clrkey}[${green}✓✓✓${clrkey}]${rst}"}"
    : "${CROSS="${clrkey}[${red}✗✗✗${clrkey}]${rst}"}"
    : "${MID="${clrkey}[${red}✗✗${green}✓${clrkey}]${rst}"}"
    : "${WARN="${clrkey}[${yellow}⚠  ${clrkey}]${yellow}"}"
    : "${INFO="${clrkey}[${yellow}➡  ${clrkey}]${rst}"}"
	else
		unset_varcolors
	fi
}

unset_varcolors() {
	unset RED GREEN YELLOW BLUE PURPLE CYAN NC RESET BOLD
	unset reset rst bold underline nounderline reverse
	unset black red green yellow blue magenta cyan white gray orange purple violet
	unset light_red light_green light_yellow light_blue light_magenta light_cyan light_white
	unset preto vermelho verde amarelo azul roxo ciano branca cinza laranja roxa violeta
	TICK="${white}[${verde}✓${rst}${white}]${rst}"
	CROSS="${white}[${roxa}✗${rst}${white}]${rst}"
	INFO="${white}[${cinza}i${rst}${white}]${rst}"
}

sh_checkroot() {
	if [[ "$(id -u)" != "0" ]]; then
		elevate_to_root "$@"
	fi
}

elevate_to_root() {
	log_err "This script must be run as root. Elevating privileges..."
	# Tenta usar sudo primeiro (caso esteja configurado)
	if command -v sudo >/dev/null 2>&1; then
		exec sudo bash "$0" "$@"
	fi
	# Se sudo falhar, tenta su
	if command -v su >/dev/null 2>&1; then
		exec su -c "$0 $*"
	fi
	die "Error: Unable to elevate privileges. Run manually as root."
}

replicate() {
  local char=${1:-'#'}
  local nsize=${2:-$(tput cols)}
  local line
  printf -v line "%*s" "$nsize" && echo -e "${blue}${line// /$char}${reset}"
}
export -f replicate

readconf() {
  local msg="$1"
  local color="${2:-${yellow}}"

  echo -n -e "$color"
  if [[ $LC_DEFAULT -eq 0 ]]; then
    read -r -p "$msg [N/s] :"
  else
    read -r -p "$msg [N/y] :"
  fi
  echo -n -e "$reset"
  case "${REPLY^}" in
  [SY]) return 0 ;;
  "") return 1 ;;
  *) return 1 ;;
  esac
}

msg() { echo -e "${INFO} ${*}${reset}"; }
msg_tab() { echo -e "  ${INFO} ${*}${reset}"; }
log_ok() { echo -e "${TICK} ${*}${reset}"; }
log_err() { echo -e "${CROSS} ${*}${reset}"; }
log_mid() { echo -e "${MID} ${*}${reset}"; }
log_warn() { echo -e "${WARN} ${*}${reset}"; }
die() {
	echo -e "${CROSS} ${red}${*}${reset}"
	exit 1
}

#########################################################################################################################

MNT="/mnt/$APP-$(date +'%H%M%S')"

# ===================================================================
# Funções auxiliares
# ===================================================================
run_cmd() {
  local cmd="$*"
  if [[ $DRYRUN -eq 1 ]]; then
    msg "${cyan}[DRY-RUN]${rst} ${cmd}"
  else
    echo -e "  [⚙  ] ${cyan}${cmd}${rst}"
#   eval "$@" &>/dev/null
#   eval "$@"
    # Executa o comando, falha se houver erro
    # Redireciona stderr para /dev/null apenas para mkdir -p e ummount -R
    if [[ "$cmd" =~ ^mkdir\ -p ]] || [[ "$cmd" =~ ^umount\ -R ]]; then
      eval "$cmd" &>/dev/null || true
    else
      eval "$cmd" || log_err "Falha ao executar: $cmd"
    fi
  fi
}

get_disk_info() {
  local disk="$1"
  lsblk -dno MODEL,SIZE,PTTYPE "$disk"
}

get_part_num() {
  local part="$1"
  local disk partnum

  # remove eventual sufixo de subvolume ([/@]) ou algo similar
  part="${part%%[*]}"

  if [[ "$part" =~ ^/dev/(nvme[0-9]+n[0-9]+|loop[0-9]+)p([0-9]+)$ ]]; then
    # nvme0n1p2 ou loop0p1
    partnum="${BASH_REMATCH[2]}"
  elif [[ "$part" =~ ^/dev/([a-z]+)([0-9]+)$ ]]; then
    # sda1, sdb2, etc
    partnum="${BASH_REMATCH[2]}"
  else
    # caso não seja partição (pode ser disco inteiro)
    partnum=""
  fi

  echo "$partnum"
}

change_efi_guid() {
  local disk="$1"      # exemplo: /dev/sda
  local efi_part="$2"  # exemplo: /dev/sda2
  local newguid="$3"   # exemplo: R para aleatório ou GUID específico
  local partnum="$(get_part_num $efi_part)"

  # define tipo da partição para EFI
  msg "Alterando tipo da partição $partnum em $disk para EFI System Partition..."
  run_cmd "sgdisk -t ${partnum}:ef00 $disk" || die "Falha ao alterar tipo para EFI"

  # altera GUID
  if [[ -z "$newguid" || "$newguid" == "R" ]]; then
    msg_tab "Gerando GUID aleatório para partição $partnum..."
    run_cmd "sgdisk -u ${partnum}:R $disk" || die "Falha ao gerar GUID aleatório" 
  else
    msg_tab "Definindo GUID ${newguid} para partição $partnum..."
    run_cmd "sgdisk -u ${partnum}:${newguid} $disk" || die "Falha ao definir GUID"
  fi

  log_ok "✔ Partição $partnum em $disk configurada como EFI com novo GUID."
}

# Função para escapar caracteres especiais no sed
escape_sed() {
  echo "$1" | sed -e 's/[\/&]/\\&/g'
}

main() {
	DEV="$1"
	if [[ -z "$DEV" ]]; then
		echo -e "${cyan}${APPDESC}${reset}"
		echo -e "${yellow}Uso:${reset}"
		echo -e "${yellow}    ${APP} /path/imagem.img ou /dev/sdX${reset}"
		exit 1
	fi

	if [[ -f "$DEV" ]]; then
		msg "Arquivo de imagem detectado: ${yellow}${DEV}${reset}"
	elif [[ -b "$DEV" ]]; then
		msg "Disco real detectado: ${yellow}${DEV}${reset}"
	else
		die "Arquivo ou dispositivo $DEV não encontrado!"
	fi

	msg "Detectando partições..."
	if [[ -b "$DEV" ]]; then
		if [[ "$DEV" =~ [0-9]$ ]]; then
			# É uma partição já pronta
			PARTS=("$DEV")
			LOOP=""
		else
			# É um disco
			PARTS=($(ls ${DEV}?* 2>/dev/null))
			LOOP=""
		fi
	else
		# É uma imagem
		LOOP=$(losetup -Pf --show "$DEV")
		PARTS=($(ls ${LOOP}p* 2>/dev/null))
	fi

	if [[ ${#PARTS[@]} -eq 0 ]]; then
		log_err "Nenhuma partição encontrada!"
		[[ -n "$LOOP" ]] && run_cmd "losetup -d $LOOP"
		exit 1
	fi

	declare -A UUIDS
	declare -A OLD_UUIDS

	# ---------- Atualizar UUID de cada partição ----------
	for PART in "${PARTS[@]}"; do
		FS=$(blkid -s TYPE -o value "$PART")
    replicate '-'
		msg "Processando $PART (FS=$FS)..."

		# Salva UUID antigo
		OLD_UUID=$(blkid -s UUID -o value "$PART")
		OLD_UUIDS[$PART]=$OLD_UUID

		# Gera novo UUID
		case "$FS" in
		ext4 | ext3 | ext2)
			run_cmd "tune2fs -U random $PART >/dev/null"
			;;
		btrfs)
			run_cmd "btrfstune -u -f $PART >/dev/null"
			;;
		xfs)
			 run_cmd "xfs_admin -U generate $PART >/dev/null"
			;;
		vfat)
			run_cmd "mlabel -s -n -i $PART :: >/dev/null"
			;;
		swap)
			msg "Partição swap detectada: $PART"
			run_cmd "swapoff $PART 2>/dev/null" || true
			run_cmd "mkswap -U random $PART"
			run_cmd "swapon $PART 2>/dev/null" || true
			;;
		*)
			msg_tab "${red}-> FS $FS não suportado, pulando."
			continue
			;;
		esac

		NEW_UUID=$(blkid -s UUID -o value "$PART")
		UUIDS[$PART]=$NEW_UUID
		msg_tab "${black}-> $PART - OLD_UUID: ${OLD_UUID}${reset}"
		msg_tab "${green}-> $PART - NEW_UUID: ${NEW_UUID}${reset}"
	done

	# ---------- Identificar root e EFI ----------
	ROOT_PART=""
	EFI_PART=""
	for PART in "${PARTS[@]}"; do
		FS=$(blkid -s TYPE -o value "$PART")
		case "$FS" in
		btrfs | ext4 | xfs) ROOT_PART="$PART" ;;
		vfat) EFI_PART="$PART" ;;
		esac
	done

	if [[ -z "$ROOT_PART" ]]; then
		die "Partição root não encontrada!"
	fi

  replicate '-'
  change_efi_guid "$DEV" "$EFI_PART" 'R'

  replicate '-'
	msg "Montando root..."
	run_cmd "mkdir -p $MNT"

	FS_ROOT=$(blkid -s TYPE -o value "$ROOT_PART")
	if [[ "$FS_ROOT" == "btrfs" ]]; then
		run_cmd "mount -o subvol=@ $ROOT_PART $MNT"
	else
		run_cmd "mount $ROOT_PART $MNT"
	fi

	if [[ -n "$EFI_PART" ]]; then
    replicate '-'
		msg "Montando EFI..."
		run_cmd "mkdir -p $MNT/boot/efi"
		run_cmd "mount $EFI_PART $MNT/boot/efi"
	fi

  replicate '-'
	msg "DEBUG: MNT contents:"
	run_cmd "ls -l $MNT/boot/grub/grub.cfg"
	run_cmd "ls -l $MNT/etc/fstab"

	# ---------- Atualizar /etc/fstab ----------
	FSTAB="$MNT/etc/fstab"
	if [[ -f "$FSTAB" ]]; then
    replicate '-'
		msg "Atualizando /etc/fstab..."
		for PART in "${PARTS[@]}"; do
			OLD_UUID=${OLD_UUIDS[$PART]}
			NEW_UUID=${UUIDS[$PART]}
			ESC_OLD=$(escape_sed "$OLD_UUID")
			ESC_NEW=$(escape_sed "$NEW_UUID")

			if [[ -n "$ESC_OLD" && -n "$ESC_NEW" ]]; then
				run_cmd "sed -i "s/$ESC_OLD/$ESC_NEW/g" $FSTAB"
				msg_tab "${green}-> [$PART] fstab atualizado: $OLD_UUID -> $NEW_UUID"
			else
				msg_tab "${red}-> [$PART] Pular partição: UUID antigo ou novo vazio"
			fi
		done
	fi

	# ---------- Atualizar grub.cfg ----------
	GRUB_CFG="$MNT/boot/grub/grub.cfg"
	if [[ -f "$GRUB_CFG" ]]; then
    replicate '-'
		msg "Atualizando grub.cfg..."
		OLD_ROOT_UUID=${OLD_UUIDS[$ROOT_PART]}
		NEW_ROOT_UUID=${UUIDS[$ROOT_PART]}
		ESC_OLD=$(escape_sed "$OLD_ROOT_UUID")
		ESC_NEW=$(escape_sed "$NEW_ROOT_UUID")

		if [[ -n "$ESC_OLD" && -n "$ESC_NEW" ]]; then
			run_cmd "sed -i "s/$ESC_OLD/$ESC_NEW/g" $GRUB_CFG"
			msg_tab "${green}-> grub.cfg atualizado: $OLD_UUID -> $NEW_UUID"
		else
			msg_tab "${red}-> Pular partição $PART: UUID antigo ou novo vazio"
		fi
	fi

	# ---------- Desmontar e liberar loop ----------
  replicate '-'
	msg "Desmontando partições..."
	if [[ -n "$EFI_PART" ]]; then
		run_cmd "umount $MNT/boot/efi" || true
	fi
	run_cmd "umount $MNT" || true
	run_cmd "rmdir $MNT" || true

	# Só libera loop se foi uma imagem
	if [[ -n "$LOOP" ]]; then
    replicate '-'
		msg "Liberando loop device..."
		run_cmd "losetup -d $LOOP"
	fi
  replicate '-'
	log_ok "UUIDs atualizados com sucesso!"
}

set_varcolors
sh_checkroot "$@"
main "$@"
