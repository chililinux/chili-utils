#!/usr/bin/env bash
# -*- coding: utf-8 -*-
# shellcheck shell=bash disable=SC1091,SC2039,SC2166,SC2034,SC2016,SC2155
#
#  chili-power-disk
#  Script para desligar ou religar um disco SSD/HDD/NVME/LOOP no Linux
#  Created: 2025/10/09 - 15:02
#  Altered: 2025/10/09 - 15:02
#  Updated: qui 09 out 2025 21:59:21 -04
#
#  Copyright (c) 2025-2025, Vilmar Catafesta <vcatafesta@gmail.com>
#  All rights reserved.
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions
#  are met:
#  1. Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
#  THIS SOFTWARE IS PROVIDED BY Vilmar Catafesta ''AS IS'' AND ANY EXPRESS OR
#  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
#  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
#  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
#  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
#  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
##############################################################################
#export LANGUAGE=pt_BR
export TEXTDOMAINDIR=/usr/share/locale
export TEXTDOMAIN=chili-desligar-disk

#debug
export PS4='${red}${0##*/}${green}[$FUNCNAME]${pink}[$LINENO]${reset}'
#set -x
#set -e
shopt -s extglob

#system
declare APP="${0##*/}"
declare _VERSION_="0.10.09-20251009"
declare APPDESC="Script para desligar ou religar um disco SSD/HDD/NVME/LOOP no Linux"
declare distro="$(uname -n)"
declare DEPENDENCIES=(tput)
declare dialogRcFile="$HOME/.dialogrc"

cleanup() { rm -f "$dialogRcFile"; }
#trap cleanup EXIT
MostraErro() { echo "erro: ${red}$1${reset} => comando: ${cyan}'$2'${reset} => result=${yellow}$3${reset}";}
#trap 'MostraErro "$APP[$FUNCNAME][$LINENO]" "$BASH_COMMAND" "$?"; exit 1' ERR

sh_check_terminal() {
  [[ ! -t 1 ]] && use_color=false
}

set_varcolors() {
  sh_check_terminal
  # does the terminal support true-color?
  if [[ -n "$(command -v "tput")" ]]; then
    #tput setaf 127 | cat -v  #capturar saida
    : "${RED=$(tput bold)$(tput setaf 196)}"
    : "${GREEN=$(tput bold)$(tput setaf 2)}"
    : "${YELLOW=$(tput bold)$(tput setaf 3)}"
    : "${BLUE=$(tput setaf 4)}"
    : "${PURPLE=$(tput setaf 125)}"
    : "${CYAN=$(tput setaf 6)}"
    : "${NC=$(tput sgr0)}"
    : "${RESET=$(tput sgr0)}"
    : "${BOLD=$(tput bold)}"
    : "${black=$(tput bold)$(tput setaf 0)}"
    : "${reverse=$(tput rev)}"
    : "${branca=${black}$(tput setab 7)}"

    : "${reset=$(tput sgr0)}"
    : "${rst=$(tput sgr0)}"
    : "${bold=$(tput bold)}"
    : "${underline=$(tput smul)}"
    : "${nounderline=$(tput rmul)}"
    : "${reverse=$(tput rev)}"

    : "${black=$(tput bold)$(tput setaf 0)}"
    : "${red=$(tput bold)$(tput setaf 196)}"
    : "${green=$(tput bold)$(tput setaf 2)}"
    : "${yellow=$(tput bold)$(tput setaf 3)}"
    : "${blue=$(tput setaf 27)}"
    : "${pink=$(tput setaf 5)}"
    : "${magenta=$(tput setaf 5)}"
    : "${cyan=$(tput setaf 6)}"
    : "${white=$(tput setaf 7)}"
    : "${gray=$(tput setaf 8)}"
    : "${light_red=$(tput setaf 9)}"
    : "${light_green=$(tput setaf 10)}"
    : "${light_yellow=$(tput setaf 11)}"
    : "${light_blue=$(tput setaf 12)}"
    : "${light_magenta=$(tput setaf 13)}"
    : "${light_cyan=$(tput setaf 14)}"
    : "${light_white=$(tput setaf 15)}"
    : "${orange=$(tput setaf 202)}"
    : "${purple=$(tput setaf 125)}"
    : "${violet=$(tput setaf 61)}"

    # Definir cores de fundo
    : "${preto=$(tput setab 0)}"
    : "${vermelho=$(tput setab 196)}"
    : "${verde=$(tput setab 2)}"
    : "${amarelo=$(tput setab 3)}"
    : "${azul=$(tput setab 20)}"
    : "${roxo=$(tput setab 5)}"
    : "${ciano=$(tput setab 6)}"
    : "${branca="${black}$(tput setab 7)"}"
    : "${cinza=$(tput setab 8)}"
    : "${laranja=$(tput setab 202)}"
    : "${roxa=$(tput setab 125)}"
    : "${violeta=$(tput setab 61)}"

    : "${COL_NC='\e[0m'}" # No Color
    : "${COL_LIGHT_GREEN='\e[1;32m'}"
    : "${COL_LIGHT_RED='\e[1;31m'}"
    : "${DONE="${COL_LIGHT_GREEN} done!${COL_NC}"}"
    : "${OVER="\\r\\033[K"}"
    : "${DOTPREFIX="  ${black}::${reset} "}"
    : "${clrkey=${light_white}}"
    : "${TICK="${clrkey}[${green}✓✓✓${clrkey}]${rst}"}"
    : "${CROSS="${clrkey}[${red}✗✗✗${clrkey}]${rst}"}"
    : "${MID="${clrkey}[${red}✗✗${green}✓${clrkey}]${rst}"}"
    : "${WARN="${clrkey}[${yellow}⚠  ${clrkey}]${yellow}"}"
    : "${INFO="${clrkey}[${yellow}➡  ${clrkey}]${rst}"}"

    # dialog colors
    REVERSE="\Zr"
    UNDERLINE="\Zu"
    BOLD="\Zb"
    RESET="\Zn"
    BLACK="\Z0"
    YELLOW="\Z3"
    AMARELO="\Zb\Z3"
    WHITE="\Z7"
    BLUE="\Z4"
    AZUL="\Zb\Z4"
    CYAN="\Z6"
    RED="\Z1"
    GREEN="\Z2"
    MAGENTA="\Z5"
  else
    unset_varcolors
  fi
}

unset_varcolors() {
  unset RED GREEN YELLOW BLUE PURPLE CYAN NC RESET BOLD
  unset reset rst bold underline nounderline reverse
  unset black red green yellow blue magenta cyan white gray orange purple violet
  unset light_red light_green light_yellow light_blue light_magenta light_cyan light_white
  unset preto vermelho verde amarelo azul roxo ciano branca cinza laranja roxa violeta
  TICK="${white}[${verde}✓${rst}${white}]${rst}"
  CROSS="${white}[${roxa}✗${rst}${white}]${rst}"
  INFO="${white}[${cinza}i${rst}${white}]${rst}"
}

sh_create_dialogrc() {
  cat > "$dialogRcFile" <<EOF_DIALOGRC
screen_color = (white,black,off)
dialog_color = (white,black,off)
title_color = (cyan,black,on)
border_color = dialog_color
shadow_color = (black,black,on)
button_inactive_color = dialog_color
button_key_inactive_color = dialog_color
button_label_inactive_color = dialog_color
button_active_color = (white,cyan,on)
button_key_active_color = button_active_color
button_label_active_color = (black,cyan,on)
tag_key_selected_color = (white,cyan,on)
item_selected_color = tag_key_selected_color
form_text_color = (BLUE,black,ON)
form_item_readonly_color = (green,black,on)
itemhelp_color = (white,cyan,off)
inputbox_color = dialog_color
inputbox_border_color = dialog_color
searchbox_color = dialog_color
searchbox_title_color = title_color
searchbox_border_color = border_color
position_indicator_color = title_color
menubox_color = dialog_color
menubox_border_color = border_color
item_color = dialog_color
tag_color = title_color
tag_selected_color = button_label_active_color
tag_key_color = button_key_inactive_color
check_color = dialog_color
check_selected_color = button_active_color
uarrow_color = screen_color
darrow_color = screen_color
form_active_text_color = button_active_color
gauge_color = title_color
border2_color = dialog_color
searchbox_border2_color = dialog_color
menubox_border2_color = dialog_color
separate_widget = ''
tab_len = 0
visit_items = off
use_shadow = off
use_colors = on
EOF_DIALOGRC
export DIALOGRC="$dialogRcFile"
}

# Testa se o terminal suporta caracteres gráficos estendidos
sh_ascii_lines() {
  #Isso força o dialog a usar caracteres ASCII básicos para as bordas.
  #if [[ "$LANG" =~ 'UTF-8' ]]; then
  if [[ "$(printf 'u250C')" =~ "┌" ]]; then
    export NCURSES_NO_UTF8_ACS=1  # Terminal suporta ACS
  else
    export NCURSES_NO_UTF8_ACS=0  # Terminal NÃO suporta ACS
  fi
}

sh_setEnvironment() {
  [[ ! -e "$dialogRcFile" ]] && sh_create_dialogrc
  sh_ascii_lines
}

sh_checkroot() {
  if [[ "$(id -u)" != "0" ]]; then
    elevate_to_root "$@"
  fi
}

elevate_to_root() {
  log_mid "This script must be run as root. Elevating privileges..."
  ccabec+='root [elevated]'
  # Tenta usar sudo primeiro (caso esteja configurado)
  if command -v sudo >/dev/null 2>&1; then
    exec sudo bash "$0" "$@"
  fi
  # Se sudo falhar, tenta su
  if command -v su >/dev/null 2>&1; then
    exec su -c "$0 $*"
  fi
  die "Error: Unable to elevate privileges. Run manually as root."
}

replicate() {
  local char=${1:-'#'}
  local nsize=${2:-$(tput cols)}
  local line
  printf -v line "%*s" "$nsize" && echo -e "${blue}${line// /$char}${reset}"
}
export -f replicate

readconf() {
  local msg="$1"
  local color="${2:-${yellow}}"

  echo -n -e "$color"
  if [[ $LC_DEFAULT -eq 0 ]]; then
    read -r -p "$msg [N/s] :"
  else
    read -r -p "$msg [N/y] :"
  fi
  echo -n -e "$reset"
  case "${REPLY^}" in
  [SY]) return 0 ;;
  "") return 1 ;;
  *) return 1 ;;
  esac
}

debug() {
# dialog
  whiptail --fb  --clear --backtitle "[debug]$0" --title "[debug]$0" --yesno "${*}\n"  0 40
  local result="$?"
  ((result)) && exit "$result"
  return "$result"
}

sh_copyright() {
  cat <<-EOF
${bold}${cyan}${0##*/} v${_VERSION_}${rst}
${bold}${cyan}${APPDESC}${rst}
${bold}${orange}Copyright (c) 2019-2025, ${reset}ChiliLinux Development Team <https://chililinux.com> <https://github.com/chililinux>${reset}
${bold}${orange}Copyright (c) 2019-2025, ${reset}Vilmar Catafesta <vcatafesta@gmail.com>${black}
EOF
}

sh_version() {
  cat <<-EOF
$(sh_copyright)

        Este é um software livre: você é livre para alterá-lo e redistribuí-lo.
        O $APP é disponibilizado para você sob a ${yellow}Licença MIT${black}, e
        inclui software de código aberto sob uma variedade de outras licenças.
        Você pode ler instruções sobre como baixar e criar para você mesmo
        o código fonte específico usado para criar esta cópia.
        ${red}Este programa vem com absolutamente NENHUMA garantia.${reset}
EOF
}

msg()          { echo -e "${INFO} ${*}${reset}"; }
log_ok()       { echo -e "${TICK} ${*}${reset}"; }
log_err()      { echo -e "${CROSS} ${*}${reset}"; }
log_mid()      { echo -e "${MID} ${*}${reset}"; }
log_warn()     { echo -e "${WARN} ${*}${reset}"; }
msg_tab()      { echo -e "  ${INFO} ${*}${reset}"; }
log_ok_tab()   { echo -e "  ${TICK} ${*}${reset}"; }
log_err_tab()  { echo -e "  ${CROSS} ${*}${reset}"; }
log_mid_tab()  { echo -e "  ${MID} ${*}${reset}"; }
log_warn_tab() { echo -e "  ${WARN} ${*}${reset}"; }
die() {
  echo -e "${CROSS} ${red}${*}${reset}"
  exit 1
}

# ===================================================================
# Funções auxiliares
# ===================================================================
run_cmd() {
  local cmd="$*"

  if [[ $DRYRUN -eq 1 ]]; then
    msg "${cyan}[DRY-RUN]${rst} ${cmd}"
  else
    echo -e "  [⚙  ] ${cyan}${cmd}${rst}"
    # Executa o comando, falha se houver erro
    # Redireciona stderr para /dev/null apenas para mkdir -p e ummount -R
    if [[ "$cmd" =~ ^mkdir\ -p ]] || [[ "$cmd" =~ ^umount\ -R ]]; then
      eval "$cmd" &>/dev/null || true
    else
      eval "$cmd" || log_warn_tab "Falha ao executar: $cmd"
    fi
  fi
}

# configure ambiente
set_varcolors

##########################################################################################################

usage() {
  echo "$APPDESC"
  echo "${orange}Uso${rst}: $APP ${yellow}[</dev/sdX>] <off/on>${rst}"
  echo "     $APP ${yellow}/dev/sdh off   ${cyan}# Desliga o disco${rst}"
  echo "     $APP ${yellow}on             ${cyan}# Religa o disco${rst}"
  echo
  log_warn "Para desligar, todas as partições do disco serão desmontadas."
  exit 1
}

# Checa parâmetros
if [[ $1 =~ ^-V|--version$ ]]; then
  sh_version
  exit 0
fi

# Checa parâmetros
if [[ $# -lt 1 || $# -gt 2 || $1 =~ ^-h|--help$ ]]; then
  usage
fi

if [[ "$1" == "on" ]]; then
  ACAO="on"
  DISK=""
else
  DISK="$1"
  ACAO="${2,,}"
  if [[ "$ACAO" != "off" ]]; then
    die "Ação inválida: '$ACAO' — use ${yellow}'off'${red} após o device. ${yellow}Ex.: $APP /dev/sdX off${rst}" >&2
  fi
fi

get_disk_info() {
  local disk="$1"
  lsblk -dno MODEL,SIZE,PTTYPE "$disk"
}

detect_fs_type() {
  local part="$1"
  lsblk -no FSTYPE "$part"
}

confirm_params() {
  msg "Disco informado:"
  msg "${cyan}--disk      ==> ${yellow}${DISK:-<não detectado>}  ${azul}[$(get_disk_info $DISK)]"
  msg "${cyan}--acao      ==> ${yellow}${ACAO:-<não informado>}"
  replicate '-'

  log_warn "ATENÇÃO: ${rst}todas as partições de ${yellow}$DISK${rst} serão desmontadas e o disco será removido do kernel!"
  if ! readconf "${red}Deseja continuar?"; then
    die "Operação cancelada."
    return 1
  fi
  msg "Continuando..."
  return 0
}

sh_checkroot "$@"
TMPFILE="/tmp/chili-power-disk-mounts.txt"

case "$ACAO" in
  off)
    # Checa se o disco existe
    if [[ ! -b "$DISK" ]]; then
      die "Erro: disco ${yellow}'$DISK'${red} não encontrado."
    fi

    replicate '-'
#   fdisk -l "$DISK"
#   smartctl -i "${DISK}"
#   run_cmd 'sgdisk -p "${DISK}"'
#   echo
    run_cmd 'lsblk -f "$DISK"'
    replicate '-'

    confirm_params

    msg "Iniciando o desligando do disco ${DISK}..."
    # Salva UUIDs e pontos de montagem
    msg_tab "Salvando informações das partições..."
    # Arquivo temporário para armazenar UUIDs e pontos de montagem
#   run_cmd 'lsblk -ln -o NAME,UUID,MOUNTPOINT "$DISK" | tail -n +2 > "$TMPFILE"'
    lsblk -ln -o NAME,UUID,MOUNTPOINT "$DISK" | tail -n +2 > "$TMPFILE"

    # Desmonta todas as partições
    msg_tab "Desmontando partições..."
    for part in $(lsblk -ln -o NAME "$DISK" | tail -n +2); do
      run_cmd "umount /dev/$part 2>/dev/null"
    done

    # Remove do kernel
    msg_tab "Removendo disco ${DISK} do kernel..."
    echo 1 | sudo tee "/sys/block/$(basename "$DISK")/device/delete" >/dev/null
    if ! fdisk -l /dev/sdc &>/dev/null; then
      log_ok_tab "Disco desligado com sucesso."
      msg_tab "Para religar, execute: $APP on"
    else
      log_err_tab "Falha ao desligar o disco."
    fi
    ;;

  on)
    msg "Religando discos..."
    # Re-scan do barramento
    echo "- - -" | sudo tee /sys/class/scsi_host/host*/scan

    # Dá um tempo para o kernel detectar
    sleep 2

    log_ok_tab "Discos religados."

    # Monta automaticamente pelo UUID salvo (precisa do TMPFILE do desligamento)
    if [[ -f "$TMPFILE" ]]; then
      msg "Montando partições..."
      while read -r name uuid mnt; do
        if [[ -n "$uuid" && -n "$mnt" ]]; then
          run_cmd "mkdir -p $mnt"
          run_cmd "mount -U $uuid $mnt"
          log_ok_tab "Montado $mnt (UUID=$uuid)"
        fi
      done < "$TMPFILE"
      rm -f "$TMPFILE"
    else
      log_warn_tab "Aviso: ${rst}arquivo de informações não encontrado. Partições não serão montadas automaticamente."
    fi
    ;;
  *)
    usage
    ;;
esac

