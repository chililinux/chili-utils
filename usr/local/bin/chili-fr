#!/usr/bin/env bash
# -*- coding: utf-8 -*-
# shellcheck shell=bash disable=SC1091,SC2039,SC2166
#
#  chili-fr - Wrapper lite para o qemu
#  Created: 2019/12/13 - 00:00
#  Altered: 2024/10/03 - 00:00
#  Updated: seg 16 fev 2026 00:50:21 -04
#
#  Copyright (c) 2019-2025, Vilmar Catafesta <vcatafesta@gmail.com>
#  All rights reserved.
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions
#  are met:
#  1. Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
#  THIS SOFTWARE IS PROVIDED BY THE AUTHOR AS IS'' AND ANY EXPRESS OR
#  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
#  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
#  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
#  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
#  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
##############################################################################
export LANGUAGE="${LANGUAGE:-pt_BR}"
export TEXTDOMAINDIR=/usr/share/locale
export TEXTDOMAIN=chili-fr
export TERM=${TERM:-xterm}
export TERM=${TERM:-xterm-256color}

#debug
export PS4='${red}${0##*/}${green}[$FUNCNAME]${pink}[$LINENO]${reset} '
#set -x
#set -e

#system
readonly APP="${0##*/}"
readonly VERSION='3.02.16-20260216'
readonly APPDESC="$(gettext 'Wrapper magro para o qemu')"
readonly -a DEPENDENCIES=(
	'tput'
	'qemu-system-x86_64'
	'spice-vdagent'
	'remote-viewer'
	'python3'
	'virsh'
	'find'
	'awk'
	'brctl'
)
readonly -A PACKAGEDEP=(
	['tput']='ncurses'
	['qemu-system-x86_64']='qemu-full'
	['spice-vdagent']='spice-vdagent'
	['remote-viewer']='virt-viewer'
	['python3']='python'
	['virsh']='libvirt'
	['find']='findutils'
	['awk']='gawk'
	['brctl']='bridge-utils'
)

declare quiet=false
declare HOME_DIR="$HOME/.chili-fr"
declare iface_bridge='br0'
declare bridge=false
declare xmem='8G'

declare videodevice='none'
declare videodevice='ati-vga'
declare videodevice='vmware-svga'
declare videodevice='cirrus'
declare videodevice='cirrus-vga'
declare videodevice='isa-cirrus-vga'
declare videodevice='isa-vga'
declare videodevice='qxl-vga'
declare videodevice='secondary-vga'
declare videodevice='virtio-vga-gl'
declare videodevice='virtio-gpu'
declare videodevice='virtio-vga-gl'
declare videodevice='virtio-gpu-pci'
declare videodevice='virtio-gpu-gl-pci'
declare videodevice='qxl-vga'
declare videodevice='bochs-display'
declare videodevice='ramfb'
declare videodevice='virtio-gpu-gl'
declare videodevice='virtio-gpu'

declare videodevice='qxl'
declare videodevice='VGA'
declare videodevice='virtio-vga'

declare lshare=false
declare spice=false
declare uefi=false
declare only_tty=false
declare drive=false
declare vdisk=false
declare output=false
declare vdisk_name=''
declare netdevice='virtio-net-pci'
declare anetdevices=()
declare netchoosedriver=false
declare LC_DEFAULT=0
declare -i lastrow=$(tput lines)
declare -i lastcol=$(tput cols)
declare -i Prow=0
declare -i Pcol=0
declare -a qemu_options=()
declare -a avdisk_names=()
trap cleanup_working_dir EXIT

function cleanup_working_dir {
	if [[ -d "${working_dir}" ]]; then
		rm -rf -- "${working_dir}"
	fi
}

sh_setvarcolors() {
	if command -v "tput" &>/dev/null; then
		tput sgr0 # reset colors
		bold=$(tput bold)
		reset=$(tput sgr0)
		rst=$(tput sgr0)
		white="${bold}$(tput setaf 7)"
		black="${bold}$(tput setaf 0)"
		red=$(tput bold)$(tput setaf 196)
		green=$(tput setaf 2)
		yellow=$(tput bold)$(tput setaf 3)
		blue=$(tput setaf 4)
		pink=$(tput setaf 5)
		cyan=$(tput setaf 6)
		orange=$(tput setaf 3)
		purple=$(tput setaf 125)
		violet=$(tput setaf 61)
	else
		red="\033[01;31m"
		green="\033[01;32m"
		yellow="\033[01;33m"
		blue="\033[01;34m"
		pink="\033[01;35m"
		cyan="\033[01;36m"
		reset="\033[0m"
	fi
	COL_NC='\e[0m' # No Color
	COL_LIGHT_GREEN='\e[1;32m'
	COL_LIGHT_RED='\e[1;31m'
	#  TICK="${white}[${COL_LIGHT_GREEN}‚úì OK${COL_NC}${white}]"
	#	CROSS="${white}[${COL_LIGHT_RED}‚úóERR${COL_NC}${white}]"
	#	INFO="[i]"
	#	: "${clrkey=${rst}${light_white}}"
	: "${clrkey=${rst}${black}}"
	: "${TICK="${clrkey}[${green} ‚úì ${clrkey}]${rst}"}"
	: "${CROSS="${clrkey}[${red} ‚úó ${clrkey}]${rst}"}"
	: "${MID="${clrkey}[${red}‚úó‚úó${green}‚úì${clrkey}]${rst}"}"
	: "${WARN="${clrkey}[${yellow}‚ö†  ${clrkey}]${yellow}"}"
	: "${INFO="${clrkey}[${yellow}‚û°  ${clrkey}]${rst}"}"
	# shellcheck disable=SC2034
	DONE="${COL_LIGHT_GREEN} done!${COL_NC}"
	OVER="\\r\\033[K"
	DOTPREFIX="  ${black}::${reset} "
}

create_menu_with_array() {
	local title=$1
	local -a options=("${!2}") # Recebe o array de op√ß√µes
	local default=${3:-}       # Op√ß√£o padr√£o, se fornecida
	local selected=0
	local key

	options+=("Encerrar")
	# Define a op√ß√£o padr√£o como selecionada inicialmente
	if [[ -n "$default" ]]; then
		for i in "${!options[@]}"; do
			if [[ "${options[$i]}" == "$default" ]]; then
				selected=$i
				break
			fi
		done
	fi

	tput civis # Esconde o cursor

	while true; do
		tput clear # Limpa a tela
		echo -e "${blue}${bold}$title${rst}\n"

		for i in "${!options[@]}"; do
			if [[ "$i" -eq $selected ]]; then
				if [[ "${options[$i]}" =~ ^(Sair|Voltar|Encerrar|Abortar)$ ]]; then
					echo -e "${red}${bold}${reverse}> ${options[$i]}${rst}"
				else
					echo -e "${green}${bold}${reverse}> ${options[$i]}${rst}"
				fi
			else
				if [[ "${options[$i]}" =~ ^(Sair|Voltar|Encerrar|Abortar)$ ]]; then
					echo -e "${red}  ${options[$i]}${rst}"
				else
					echo "  ${options[$i]}"
				fi
			fi
		done

		read -rsn1 key
		case "$key" in
		A)
			((selected--))
			[ $selected -lt 0 ] && selected=$((${#options[@]} - 1))
			;;
		B)
			((selected++))
			[ $selected -eq ${#options[@]} ] && selected=0
			;;
		'') break ;;
		esac
	done

	tput cnorm # Mostra o cursor novamente
	#	echo -e "\nVoc√™ selecionou: ${green}${bold}${options[$selected]}${rst}"
	MENU_RESULT=${options[$selected]}
	if [[ "$MENU_RESULT" =~ ^(Sair|Voltar|Encerrar|Abortar)$ ]]; then
		die "$MENU_RESULT"
	fi
	#	return $((selected+1))
}

get() {
	local row="$1"
	local col="$2"
	local prompt="$3"
	local new_value="$4"
	local old_value="$5"
	local color="${Acores[box]}"

	# setpos "$row" "$col"
	printf "%s" "${reset}$color"
	read -p "${prompt}${reverse}" -e -i "$old_value" "$new_value"
	# tput sc # Salva a posi√ß√£o atual do cursor
	echo -n -e "$reset"
}

row() { echo "$Prow"; }
col() { echo "$Pcol"; }
lastrow() { echo "$(tput lines)"; }
lastcol() { echo "$(tput cols)"; }

setpos() {
	local row="$1"
	local col="$2"

	Prow="$row"
	Pcol="$col"
	# tput cup "$row" "$col"
	printf "\e[$((row + 1));$((col + 1))H"
}

sh_unsetvarcolors() {
	unset bold reset cyan red blue white black
	unset green yellow orange pink cyan purple violet
}

die() {
	local msg="$1"
	shift
	printf "%b %s\n" "${CROSS}" "${red}${msg}${rst}"
	exit 1
}

log_err() {
	printf "%b %s\n" "${CROSS}" "${*}"
}

log_ok() {
	printf "%b %s\n" "${TICK}" "${*}"
}

log_msg() {
	local retval="${PIPESTATUS[0]}"
	local pcount=$#

	((pcount >= 2)) && {
		retval=$1
		shift
	}
	if [[ $retval -eq 0 ]]; then
		$quiet || printf "%b %s\n" "${TICK}" "${*}"
	else
		$quiet || printf "%b %s\n" "${CROSS}" "${*}"
	fi
}

msg_raw() {
	local msg="$1"
	# Remove tags HTML, se existirem
	#msg="$(sed 's/<[^>]*>//g' <<< "$msg")"

	# Verifica se existe ':' na mensagem
	if [[ "$msg" == *:* ]]; then
		# Divide a string antes e depois do primeiro ':'
		local before_colon="${msg%%:*}:"
		local after_colon="${msg#*: }"
		# Aplica as cores
		msg="${cyan}${before_colon} ${red}${after_colon}${reset}"
	else
		# Se n√£o houver ':', aplica apenas a cor padr√£o
		msg="${yellow}${cyan}${msg}${reset}"
	fi
	echo -e "$msg"
}
export -f msg_raw

msg() {
	local msg="$1"
	msg="$(sed 's/<[^>]*>//g' <<<"$msg")" # Remove as tags HTML
	echo -e "  =>${cyan}running: ${yellow}${msg}${reset}"
}
export -f msg

msg_ok() {
	local msg="$1"
	#  echo -e "  =>${cyan}feito: ${green}${msg}${reset}"
	echo -e "${TICK} ${green}${*}${rst}"
}
export -f msg_ok

msg_run() {
	local msg="$1"
	echo -e "BP=>${cyan}running: ${yellow}${msg}${reset}"
	eval "$msg"
}
export -f msg_run

msg_info() { $quiet || echo -e "${INFO} ${*}${reset}"; }
msg_info_tab() { $quiet || echo -e "  ${INFO} ${*}${reset}"; }
msg() { $quiet || echo -e "${INFO} ${*}${reset}"; }
log_ok() { $quiet || echo -e "${TICK} ${*}${reset}"; }
log_err() { $quiet || echo -e "${CROSS} ${*}${reset}"; }
log_mid() { $quiet || echo -e "${MID} ${*}${reset}"; }
log_warn() { $quiet || echo -e "${WARN} ${*}${reset}"; }
msg_ex_tab() { $quiet || echo -e "  üëâ   ${*}${reset}"; }
msg_ex() { $quiet || echo -e "üëâ   ${*}${reset}"; }
msg_tab() { $quiet || echo -e "  ${INFO} ${*}${reset}"; }
log_ok_tab() { $quiet || echo -e "  ${TICK} ${*}${reset}"; }
log_err_tab() { $quiet || echo -e "  ${CROSS} ${*}${reset}"; }
log_mid_tab() { $quiet || echo -e "  ${MID} ${*}${reset}"; }
log_warn_tab() { $quiet || echo -e "  ${WARN} ${*}${reset}"; }
die() {
	echo -e "${CROSS} ${red}${*}${reset}"
	exit 1
}

msg_warning() {
	local msg="$*"
	#	echo -e "  =>${yellow}warning: ${cyan}${msg}${reset}"
	echo -e "${WARN} ${*}${reset}"
}
export -f msg_warning

msg_warn() {
	local msg="$1"
	#	printf "%s\n" "${yellow}[WARN] ${cyan}$msg${rst}"
	echo -e "${WARN} ${*}${reset}"
}
export -f msg_warn

# Fun√ß√£o para exibir mensagens informativas
msg_err() {
	#	printf "%s\n" "${red}[ERRO] ${cyan}$1${rst}"
	echo -e "${CROSS} ${*}${reset}"
}

replicate() {
	local char=${1:-'#'}
	local nsize=${2:-$(tput cols)}
	local ccolor=${3:-$green}
	local line
	printf -v line "%*s" "$nsize" && echo -e "${ccolor}${line// /$char}${rst}"
}
export -f replicate

maxcol() {
	COLUMNS=$(stty size)
	COLUMNS=${COLUMNS##* }
	((COLUMNS <= 0)) && COLUMNS=80
	echo "$COLUMNS"
}

readconf() {
	local msg="$1"
	local color="${2:-${red}}"

	echo -n -e "$color"
	if [[ $LC_DEFAULT -eq 0 ]]; then
		read -r -p "$msg [S/n]"
	else
		read -r -p "$msg [Y/n]"
	fi
	echo -n -e "$reset"
	case "${REPLY^}" in
	[SY]) return 0 ;;
	"") return 0 ;;
	*) return 1 ;;
	esac
}

sh_checkDependencies() {
	local aBlock_files=()
	local d
	local errorFound=false
	declare -a missing

	for d in "${DEPENDENCIES[@]}"; do
		if ! command -v "$d" &>/dev/null; then
			log_err "Check: ${red}ERROR${rst}: $(gettext 'N√£o foi poss√≠vel encontrar o comando') ${cyan}'$d'${rst} -> $(gettext 'instalar pacote') ${cyan}${PACKAGEDEP[$d]}${rst}"
			missing+=("$d")
			errorFound=true
		else
			#log_msg "Check: ${cyan}$d"
			:
		fi
	done

	if $errorFound; then
		replicate '='
		echo "${yellow}             $(gettext 'IMPOSS√çVEL CONTINUAR')"
		echo "${black}$(gettext 'Este script precisa dos comandos listados acima')"
		echo "${black}$(gettext 'Instale-os e/ou verifique se eles est√£o em seu') ${red}\$PATH${rst}"
		replicate '='
		if readconf "$(gettext 'Deseja instalar os pacotes e criar os arquivos necess√°rios?')"; then
			sh_setup
		fi
	fi
}
export -f sh_checkDependencies

sh_checkVdiskFiles() {
	local aBlock_files=()
	local d
	local errorFound=false
	declare -a missing

	aBlock_files+=($HOME_DIR/vdisk/sda.img)
	aBlock_files+=($HOME_DIR/vdisk/sdb.img)
	aBlock_files+=($HOME_DIR/vdisk/sdc.img)
	aBlock_files+=($HOME_DIR/vdisk/sdd.img)
	aBlock_files+=($HOME_DIR/vdisk/vda.qcow2)
	aBlock_files+=($HOME_DIR/vdisk/vdb.qcow2)
	aBlock_files+=($HOME_DIR/vdisk/vdc.qcow2)
	aBlock_files+=($HOME_DIR/vdisk/vdd.qcow2)
	for d in "${aBlock_files[@]}"; do
		if [[ ! -e "$d" ]]; then
			sh_createVdiskFiles
			break
		fi
	done
}

sh_checkOVMFFiles() {
	local aBlock_files=()
	local d
	local errorFound=false
	declare -a missing

	aBlock_files+=('/usr/share/edk2/x64/OVMF_CODE.4m.fd')
	aBlock_files+=('/usr/share/edk2/x64/OVMF_VARS.4m.fd')
	for d in "${aBlock_files[@]}"; do
		if [[ ! -e "$d" ]]; then
			log_err "Check: ${red}ERROR${rst}: $(gettext 'N√£o foi poss√≠vel encontrar o arquivo') ${cyan}'$d'${yellow} -> $(gettext 'instalar pacote') ${cyan}edk2-ovmf${reset}"
			errorFound=true
			break
		else
			true
			log_msg "Check UEFI: ${cyan}$d"
			:
		fi
	done

	if $errorFound; then
		replicate '='
		echo "${yellow}             FALHA DO CHECK LIST FILE"
		echo "${black}Este script precisa dos arquivos para UEFI listados acima"
		echo "${black}Instale-os e/ou verifique se eles est√£o em ${yellow}/usr/share/edk2/x64/${rst}"
		echo "${black}Ao decidir n√£o instalar, o UEFI poder√° n√£o funcionar corretamente.${rst}"
		replicate '='
		if readconf "Deseja instalar o pacote e suprir arquivos necess√°rios ?"; then
			sudo pacman -S --quiet --noconfirm edk2-ovmf 1>/dev/null
		fi
	fi
}

# Fun√ß√£o para verificar se a interface TAP j√° existe e retornar o pr√≥ximo n√∫mero dispon√≠vel
get_next_free_tap() {
	local next_tap=1
	while ip link show "tap$next_tap" &>/dev/null; do
		next_tap=$((next_tap + 1))
	done
	echo "tap$next_tap"
}

# Fun√ß√£o para verificar se a bridge existe e retornar o pr√≥ximo nome dispon√≠vel
get_next_free_bridge() {
	local base_bridge="virbr"
	local next_bridge=1
	while ip link show "$base_bridge$next_bridge" &>/dev/null; do
		next_bridge=$((next_bridge + 1))
	done
	echo "$base_bridge$next_bridge"
}

# ---------------------------
# cmd_sudo wrapper
# ---------------------------
cmd_sudo() {
	if [[ $EUID -eq 0 ]]; then
		"$@"
	else
		sudo "$@"
	fi
}

ensure_qemu_bridge_allowed() {
	local br="$1"
	local conf="/etc/qemu/bridge.conf"

	# se arquivo n√£o existe ‚Äî cria
	if [[ ! -f "$conf" ]]; then
		# Garantir que /etc/qemu existe
		cmd_sudo mkdir -p /etc/qemu &>/dev/null
		cmd_sudo sh -c "echo 'allow ${br}' > '$conf'"
		return 0
	fi

	# verifica se j√° est√° presente (ignora espa√ßos e duplicidades)
	if cmd_sudo grep -Eq "^[[:space:]]*allow[[:space:]]+${br}[[:space:]]*$" "$conf"; then
		msg_ok "Bridge ${cyan}'${br}'${rst} j√° est√° permitida no $conf"
		return 0
	fi

	# adicionar no final do arquivo
	msg_info "$(gettext 'Adicionando') 'allow ${br}' $(gettext 'em') $conf"
	cmd_sudo sh -c "echo 'allow ${br}' >> '$conf'"
	return 0
}

######################################################################################################
#  BRIDGE REAL (tipo VirtualBox) ‚Äì sem NAT
######################################################################################################
create_real_bridge() {
	local bridge_name="$1"
	local iface_phys
	local old_con
	local kernel_master
	local use_dhcp=false
	local bridge_ip
	local bridge_gw

	[[ -z "$bridge_name" ]] && {
		msg_err "$(gettext 'Uso correto'): --create_real_bridge br0"
		return 1
	}

	msg_info "$(gettext 'Verificando se a bridge') '$bridge_name' $(gettext 'j√° existe')"
	if ip link show "$bridge_name" &>/dev/null; then
		msg_warning "$(gettext 'Ponte') '${bridge_name}' $(gettext 'j√° existe ‚Äî nada a fazer.')"
		cmd_sudo nmcli connection show
		return 0
	fi

	# DETECTAR INTERFACES F√çSICAS (ETHERNET)
	###########################################################################
	msg_info "$(gettext 'Detectando interfaces f√≠sicas (ethernet)')"
	local -a eth_list
	mapfile -t eth_list < <(
		nmcli -t -f DEVICE,TYPE device | awk -F: '$2=="ethernet"{print $1}'
	)

	if [[ ${#eth_list[@]} -eq 0 ]]; then
		msg_err "$(gettext 'Nenhuma interface ethernet dispon√≠vel. WLAN n√£o suporta bridge real.')"
		return 1
		#  elif [[ ${#eth_list[@]} -eq 1 ]]; then
		#    iface_phys="${eth_list[0]}"
		#    msg_info "Apenas uma interface f√≠sica encontrada: $iface_phys"
	else
		msg_info "$(gettext 'M√∫ltiplas interfaces encontradas ‚Äî exibindo menu de sele√ß√£o')"
		create_menu_with_array "$(gettext 'Escolha a interface f√≠sica para a bridge:')" eth_list[@]
		iface_phys="$MENU_RESULT"
		if [[ "$iface_phys" == "$(gettext 'Encerrar')" ]]; then
			msg_info "$(gettext 'Opera√ß√£o cancelada pelo usu√°rio.')"
			return 1
		fi
		msg_info "$(gettext 'Interface selecionada:') $iface_phys"
	fi

	# PROTE√á√ÉO ‚Äî INTERFACE N√ÉO PODE SER WLAN
	###########################################################################
	if nmcli -t -f DEVICE,TYPE device | grep -q "^${iface_phys}:wifi$"; then
		msg_err "$(gettext 'A interface') '$iface_phys' $(gettext '√© Wi-Fi. Bridge real n√£o funciona com WLAN.')"
		return 1
	fi

	# VERIFICAR SE INTERFACE J√Å √â SLAVE
	###########################################################################
	msg_info "$(gettext 'Verificando se') '$iface_phys' $(gettext 'j√° pertence a outra bridge')"
	kernel_master=$(ip -o link show "$iface_phys" | sed -n 's/.*master \([^ ]*\).*/\1/p' || true)
	if [[ -n "$kernel_master" ]]; then
		msg_err "$(gettext 'Interface') '$iface_phys' $(gettext 'j√° pertence √† bridge') '$kernel_master'."
		msg_warning "$(gettext 'Remova primeiro:') chili-fr -r $kernel_master"
		return 1
	fi

	# MENU VLAN
	###########################################################################
	msg_info "$(gettext 'Configura√ß√£o de VLAN')"
	local -a vlan_options=(
		"$(gettext 'Sem VLAN (rede normal)')"
		"VLAN Tagged ($(gettext 'criar') ${iface_phys}.<id> $(gettext 'e usar como slave'))"
		"VLAN Trunk (bridge vlan-filtering $(gettext 'habilitado'))"
	)
	create_menu_with_array "$(gettext 'Selecione o modo VLAN:')" vlan_options[@]

	local vlan_choice
	case "$MENU_RESULT" in
	"$(gettext 'Sem VLAN (rede normal)')") vlan_choice="none" ;;
	"VLAN Tagged ($(gettext 'criar') ${iface_phys}.<id> $(gettext 'e usar como slave)')") vlan_choice="tagged" ;;
	"VLAN Trunk (bridge vlan-filtering $(gettext 'habilitado')") vlan_choice="trunk" ;;
	*)
		msg_err "$(gettext 'Erro inesperado no menu VLAN')"
		return 1
		;;
	esac
	msg_info "$(gettext 'Modo VLAN selecionado:') ${cyan}$vlan_choice${rst}"

	local vlan_id="" slave_iface="" want_vlan_trunk=false
	if [[ "$vlan_choice" == "tagged" ]]; then
		while true; do
			get 0 0 "$(gettext 'Digite o VLAN ID') (1‚Äì4094): " vlan_id ""
			if [[ "$vlan_id" =~ ^[0-9]+$ && "$vlan_id" -ge 1 && "$vlan_id" -le 4094 ]]; then
				slave_iface="${iface_phys}.${vlan_id}"
				msg_info "$(gettext 'Subinterface VLAN definida:') $slave_iface"
				break
			fi
			msg_err "$(gettext 'VLAN inv√°lida: informe um n√∫mero entre 1 e 4094')."
		done

	elif [[ "$vlan_choice" == "trunk" ]]; then
		want_vlan_trunk=true
		msg_info "$(gettext 'Bridge atuar√° como trunk') (vlan-filtering)."

		local vlan_list_raw
		while true; do
			get 0 0 "$(gettext 'Informe VLANs permitidas separadas por v√≠rgula') (ex: 10,20,30): " vlan_list_raw ""
			vlan_list_raw="${vlan_list_raw// /}"
			IFS=',' read -r -a trunk_vlans <<<"$vlan_list_raw"
			local ok=true
			declare -A _seen=()
			for v in "${trunk_vlans[@]}"; do
				if ! [[ "$v" =~ ^[0-9]+$ && "$v" -ge 1 && "$v" -le 4094 ]]; then
					msg_err "$(gettext 'VLAN inv√°lida:') $v"
					ok=false
					break
				fi
				if [[ -n "${_seen[$v]}" ]]; then
					msg_err "$(gettext 'VLAN duplicada:') $v"
					ok=false
					break
				fi
				_seen[$v]=1
			done
			[[ "$ok" == true ]] && break
		done
	fi

	# CAPTURAR IP/GW
	###########################################################################
	if [[ -n "$slave_iface" ]]; then
		msg_info "$(gettext 'Detectando IP na subinterface VLAN') '$slave_iface'"
		bridge_ip=$(nmcli -g IP4.ADDRESS device show "$slave_iface" 2>/dev/null | head -n1 || true)
		bridge_gw=$(nmcli -g IP4.GATEWAY device show "$slave_iface" 2>/dev/null | head -n1 || true)
		if [[ -z "$bridge_ip" ]]; then
			msg_info "$(gettext 'Usando IP da interface f√≠sica') '$iface_phys'"
			bridge_ip=$(nmcli -g IP4.ADDRESS device show "$iface_phys" | head -n1)
			bridge_gw=$(nmcli -g IP4.GATEWAY device show "$iface_phys")
		fi
	else
		msg_info "$(gettext 'Obtendo IP atual da interface') ${cyan}'$iface_phys'${rst}"
		bridge_ip=$(nmcli -g IP4.ADDRESS device show "$iface_phys" | head -n1)
		bridge_gw=$(nmcli -g IP4.GATEWAY device show "$iface_phys")
	fi

	if [[ -z "$bridge_ip" ]]; then msg_warning "$(gettext 'Nenhum IP detectado automaticamente.')"; fi
	if [[ -z "$bridge_gw" ]]; then msg_warning "$(gettext 'Nenhum gateway detectado.')"; fi

	local original_ip_pure="${bridge_ip%%/*}"

	# SOLICITAR E VALIDAR IP
	###########################################################################
	msg_info "$(gettext 'Configurando IP da bridge') ${cyan}'$bridge_name'${rst}"

	if readconf "Usar DHCP?"; then
		use_dhcp=true
	else
		while true; do
			get 0 0 "IP (ex 192.168.2.70/24): " tmp_ip "$bridge_ip"
			bridge_ip="${tmp_ip:-$bridge_ip}"

			if [[ ! "$bridge_ip" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}/[0-9]{1,2}$ ]]; then
				msg_err "$(gettext 'Formato inv√°lido.')"
				continue
			fi

			local candidate_ip="${bridge_ip%%/*}"
			if [[ "$candidate_ip" == "$original_ip_pure" ]]; then
				msg_info "$(gettext 'IP igual ao atual ‚Äî pulando teste.')"
				break
			fi

			msg_info "$(gettext 'Validando se IP est√° em uso...')"
			if command -v arping >/dev/null 2>&1; then
				if cmd_sudo arping -c2 -w1 -I "$iface_phys" "$candidate_ip" >/dev/null 2>&1; then
					msg_err "$(gettext 'Conflito ARP detectado.')"
					continue
				else
					break
				fi
			fi
			break
		done

		while true; do
			get 0 0 "Gateway (ex 192.168.2.1): " tmp_gw "$bridge_gw"
			bridge_gw="${tmp_gw:-$bridge_gw}"
			if [[ ! "$bridge_gw" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]; then
				msg_err "$(gettext 'Gateway inv√°lido')."
				continue
			fi
			if ! ping -c1 -W1 "$bridge_gw" >/dev/null; then
				msg_warning "$(gettext 'Gateway n√£o respondeu.')"
				readconf "$(gettext 'Continuar?')" && break || continue
			fi
			break
		done
	fi

	# CRIAR BRIDGE E SLAVE
	###########################################################################
	msg_info "$(gettext 'Criando ponte') ${cyan}'$bridge_name'${rst}"
	cmd_sudo nmcli connection add type bridge ifname "$bridge_name" con-name "$bridge_name" \
		stp no ipv6.method ignore autoconnect yes >/dev/null || {
		msg_err "$(gettext 'Falha ao criar ponte')"
		return 1
	}

	local slave_to_use
	if [[ -n "$slave_iface" ]]; then
		if ! ip link show "$slave_iface" &>/dev/null; then
			msg_info "$(gettext 'Criando subinterface') VLAN $slave_iface"
			cmd_sudo nmcli connection add type vlan ifname "$slave_iface" dev "$iface_phys" id "$vlan_id" \
				con-name "vlan-${iface_phys}.${vlan_id}" ipv4.method disabled ipv6.method ignore >/dev/null || {
				msg_err "$(gettext 'Falha ao criar VLAN')"
				return 1
			}
			sleep 1
		fi
		slave_to_use="$slave_iface"
	else
		slave_to_use="$iface_phys"
	fi

	# criar slave da bridge apontando para slave_to_use
	msg_info "$(gettext 'Criando conex√£o slave para') ${cyan}'$slave_to_use'${rst}"
	local slave_name="${bridge_name}-${slave_to_use}-$(uuidgen | cut -c1-8)"

	cmd_sudo nmcli connection add type bridge-slave ifname "$slave_to_use" con-name "$slave_name" \
		master "$bridge_name" autoconnect yes >/dev/null || {
		msg_err "$(gettext 'Falha ao criar slave') '$slave_name'"
		return 1
	}

	# VLAN TRUNK
	###########################################################################
	if [[ "$vlan_choice" == "trunk" ]]; then
		msg_info "$(gettext 'Ativando') vlan-filtering"
		cmd_sudo nmcli connection modify "$bridge_name" bridge.vlan-filtering yes

		for v in "${trunk_vlans[@]}"; do
			msg_info "$(gettext 'Adicionando') VLAN $v $(gettext 'ao') trunk"
			cmd_sudo bridge vlan add dev "$iface_phys" vid "$v" master "$bridge_name" 2>/dev/null ||
				msg_warning "$(gettext 'Falha ao adicionar') VLAN $v"
		done
	fi

	# DESATIVAR CONEX√ÉO ANTIGA
	###########################################################################
	msg_info "$(gettext 'Desativando conex√£o antiga da interface f√≠sica')"
	old_con=$(nmcli -t -f NAME,DEVICE connection show | grep ":$iface_phys$" | cut -d: -f1 || true)
	if [[ -n "$old_con" ]]; then
		cmd_sudo nmcli connection down "$old_con" &>/dev/null
		cmd_sudo nmcli connection modify "$old_con" connection.autoconnect no
	fi

	# CONFIGURAR IP NA BRIDGE
	###########################################################################
	if [[ "$use_dhcp" == true ]]; then
		msg_info "$(gettext 'Ativando DHCP na ponte') ${cyan}'$bridge_name'${rst}"
		cmd_sudo nmcli connection modify "$bridge_name" ipv4.method auto ipv4.never-default no >/dev/null
	else
		msg_info "$(gettext 'Aplicando IP manual')"
		cmd_sudo nmcli connection modify "$bridge_name" \
			ipv4.method manual \
			ipv4.addresses "$bridge_ip" \
			ipv4.gateway "$bridge_gw" \
			ipv4.dns-search "" \
			ipv6.method ignore >/dev/null
	fi

	# ATIVAR A BRIDGE
	###########################################################################
	msg_info "$(gettext 'Ativando ponte') ${cyan}'$bridge_name'${rst}"
	cmd_sudo nmcli connection up "$bridge_name" >/dev/null

	# RESUMO
	###########################################################################
	msg_info_tab "${green}---------- $(gettext 'RESUMO') ----------${rst}"
	msg_info_tab "$(gettext 'Ponte')            : ${green}$bridge_name${rst}"
	msg_info_tab "$(gettext 'Interface f√≠sica') : ${green}$iface_phys${rst}"
	msg_info_tab "Slave            : ${green}$slave_to_use${rst}"
	msg_info_tab "$(gettext 'Conex√£o') slave    : ${green}$slave_name${rst}"

	case "$vlan_choice" in
	none) msg_info_tab "VLAN             : ${green}$(gettext 'nenhuma')${rst}" ;;
	tagged) msg_info_tab "VLAN Tagged      : ${green}$vlan_id${rst}" ;;
	trunk) msg_info_tab "Trunk            : ${green}VLANs ${trunk_vlans[*]}${rst}" ;;
	esac

	if [[ "$use_dhcp" == true ]]; then
		msg_info_tab "IP               : ${green}DHCP${rst}"
	else
		msg_info_tab "IP $(gettext 'aplicado')      : ${green}$bridge_ip${rst}"
		msg_info_tab "Gateway          : ${green}$bridge_gw${rst}"
	fi

	msg_info_tab "${green}-----------------------------${rst}"
	ensure_qemu_bridge_allowed "$bridge_name"
	msg_ok "$(gettext 'Ponte') ${cyan}'$bridge_name'${rst} $(gettext 'criada e configurada com sucesso.')"
	return 0
}

remove_real_bridge() {
	local bridge_name="$1"
	local iface_phys
	local slave_con
	local bridge_ip
	local bridge_gw

	[[ -z "$bridge_name" ]] && {
		msg_err "Uso: chili-fr -r br0"
		return 1
	}

	# DETECTAR INTERFACE F√çSICA SLAVE
	###########################################################################
	msg_info "$(gettext 'Removendo') bridge '$bridge_name' $(gettext 'com seguran√ßa (sem derrubar SSH)')"
	iface_phys=$(ip -o link show | grep -w "master $bridge_name" | awk -F: '{print $2}' | awk '{print $1}')
	#   iface_phys=$(
	#     ip -o link show \
	#     | awk -v br="$bridge_name" '
	#         $0 ~ ("master " br) {
	#           split($2, a, ":");
	#           print a[1];
	#           exit;
	#         }
	#       '
	#   )

	if [[ -z "$iface_phys" ]]; then
		msg_err "$(gettext 'N√£o foi poss√≠vel detectar interface f√≠sica slave.')"
		return 1
	fi

	msg_info "$(gettext 'Interface f√≠sica slave detectada:') ${cyan}$iface_phys${rst}"

	# ACHAR PERFIL SLAVE (f√°cil)
	###########################################################################
	slave_con=$(
		nmcli -t -f NAME,TYPE connection show 2>/dev/null |
			grep -m1 "^${bridge_name}-${iface_phys}.*802-3-ethernet" |
			cut -d: -f1
	)

	if [[ -z "$slave_con" ]]; then
		msg_warning "$(gettext 'Nenhum perfil slave encontrado ‚Äî talvez j√° removido.')"
	else
		msg_info "$(gettext 'Perfil slave encontrado:') ${cyan}$slave_con${rst}"
	fi

	###########################################################################
	# PEGAR IP E GATEWAY ATUAIS DA BRIDGE
	###########################################################################
	bridge_ip=$(nmcli -g IP4.ADDRESS device show "$bridge_name" | head -n1)
	bridge_gw=$(nmcli -g IP4.GATEWAY device show "$bridge_name" | head -n1)

	msg_info "$(gettext 'IP atual na') bridge: ${cyan}${bridge_ip:-nenhum}${rst}"
	msg_info "Gateway: ${cyan}${bridge_gw:-nenhum}${rst}"

	# IDENTIFICAR PERFIL F√çSICO CORRETO  (teu m√©todo definitivo)
	###########################################################################
	phys_con=$(
		nmcli -t -f NAME,DEVICE,TYPE,SLAVE connection show |
			awk -F: -v dev="$interface" '
        $3 ~ /802-3-ethernet/ && ($2 == dev || $2 == "") && $4 != "bridge" {print $1; exit}
    '
	)

	if [[ -z "$phys_con" ]]; then
		msg_err "$(gettext 'N√£o foi poss√≠vel localizar o perfil f√≠sico verdadeiro para') '$iface_phys'."
		return 1
	fi
	msg_info "$(gettext 'Perfil f√≠sico real:') ${cyan}$phys_con${rst}"

	# RESTAURAR AUTOCONNECT + IP NA F√çSICA (ANTES DE REMOVER A BRIDGE)
	###########################################################################
	msg_info_tab "$(gettext 'Restaurando autoconnect da interface f√≠sica')"
	cmd_sudo nmcli connection modify "$phys_con" connection.autoconnect yes

	if [[ -n "$bridge_ip" ]]; then
		msg_info_tab "$(gettext 'Aplicando') IP ($bridge_ip) $(gettext 'de volta na interface f√≠sica')"
		cmd_sudo nmcli connection modify "$phys_con" ipv4.method manual
		cmd_sudo nmcli connection modify "$phys_con" ipv4.addresses "$bridge_ip"
		[[ -n "$bridge_gw" ]] && cmd_sudo nmcli connection modify "$phys_con" ipv4.gateway "$bridge_gw"
	else
		msg_info_tab "$(gettext 'Sem IP detectado ‚Äî configurando interface f√≠sica para DHCP')"
		cmd_sudo nmcli connection modify "$phys_con" ipv4.method auto
	fi

	# SUBIR INTERFACE F√çSICA AGORA (ANTES DE REMOVER A BRIDGE)
	###########################################################################
	msg_info_tab "$(gettext 'Subindo interface f√≠sica ANTES de remover a bridge')"
	echo -n "$green"
	cmd_sudo nmcli connection up "$phys_con" || msg_warning "$(gettext 'Falha ao subir interface f√≠sica ‚Äî pode ser esperado via SSH')"
	echo -n "$rst"

	# REMOVER PERFIL SLAVE
	###########################################################################
	if [[ -n "$slave_con" ]]; then
		msg_info_tab "$(gettext 'Removendo conex√£o slave') '$slave_con'"
		echo -n "$green"
		cmd_sudo nmcli connection delete "$slave_con"
		echo -n "$rst"
	fi

	# REMOVER A BRIDGE
	###########################################################################
	msg_info_tab "$(gettext 'Desativando') bridge '$bridge_name'"
	echo -n "$green"
	cmd_sudo nmcli connection down "$bridge_name" 2>/dev/null
	echo -n "$rst"

	msg_info_tab "$(gettext 'Removendo perfil da') bridge"
	echo -n "$green"
	cmd_sudo nmcli connection delete "$bridge_name" 2>/dev/null
	echo -n "$rst"

	msg_ok "Bridge '$bridge_name' $(gettext 'removida com sucesso e interface') '$iface_phys' $(gettext 'restaurada.')"
}

create_bridge_virbr() {
	local bridge_name="$1"

	if sudo virsh -c qemu:///system net-list --all &>/dev/null; then
		msg_info "virsh $(gettext 'est√° funcionando e conseguiu listar as redes.')"
	else
		msg_warning "virsh $(gettext 'n√£o conseguiu se conectar ao libvirt.')"
		msg_warning "$(gettext 'Verifique se o servi√ßo libvirtd est√° ativo com os comandos abaixo:')\n\
sudo systemctl status libvirtd.service
sudo systemctl status libvirtd.socket"
		msg_warning "$(gettext 'DICA: Tente ativar com os comandos abaixo:')\n\
sudo systemctl enable --now libvirtd virtqemud
sudo systemctl restart libvirtd.service"
		die "$(gettext 'Erro fatal')"
	fi

	if [[ -z "$bridge_name" ]]; then
		# Obter o pr√≥ximo nome de bridge dispon√≠vel
		bridge_name=$(get_next_free_bridge)
	fi

	# Criar a rede virsh correspondente √† nova bridge
	if sudo virsh net-list --all 1>/dev/null; then
		if ! sudo virsh net-list --all | grep -q "$bridge_name" 1>/dev/null; then
			msg_info "$(gettext 'Criando a rede') $bridge_name..."

			# Calcular a faixa de IP com base no nome da bridge
			# O n√∫mero da bridge ser√° extra√≠do (ex: virbr1 -> 1, virbr2 -> 2, etc.)
			bridge_number=$(echo "$bridge_name" | grep -o '[0-9]*')
			base_ip="172.$((30 + bridge_number)).255.1"
			GATEWAY="$base_ip"
			subnet="255.255.255.0"
			dhcp_range_start="172.$((30 + bridge_number)).255.2"
			dhcp_range_end="172.$((30 + bridge_number)).255.200"

			# Criando o arquivo de configura√ß√£o tempor√°rio para a rede
			tmp_net_config=$(mktemp)

			cat <<EOF >"$tmp_net_config"
<!--
WARNING: THIS IS AN AUTO-GENERATED FILE. CHANGES TO IT ARE LIKELY TO BE
OVERWRITTEN AND LOST. Changes to this xml configuration should be made using:
  virsh net-edit $bridge_name
or other application using the libvirt API.
-->

<network>
  <name>$bridge_name</name>
  <uuid>$(uuidgen)</uuid>
  <forward mode='nat'/>
  <bridge name='$bridge_name' stp='on' delay='0'/>
  <ip address='$base_ip' netmask='$subnet'>
    <dhcp>
      <range start='$dhcp_range_start' end='$dhcp_range_end'/>
    </dhcp>
  </ip>
</network>
EOF
			# Definir a rede usando o arquivo tempor√°rio
			sudo virsh net-define "$tmp_net_config" 1>/dev/null
			# Remover o arquivo de configura√ß√£o tempor√°rio ap√≥s a defini√ß√£o
			sudo rm -f "$tmp_net_config"
		fi
	else
		die "$(gettext 'erro fatal!')"
	fi

	# Tornar a nova bridge persistente
	msg_info "$(gettext 'Tornando') $bridge_name $(gettext 'persistente...')"
	msg_info "$(gettext 'Iniciando a rede') $bridge_name..."
	sudo virsh net-autostart "$bridge_name" 1>/dev/null

	if ! sudo virsh net-start "$bridge_name" 1>/dev/null; then
		msg_err "$(gettext 'Falha ao iniciar a rede') $bridge_name. $(gettext 'Tentando novamente.')"
		sudo virsh net-destroy "$bridge_name" 1>/dev/null
		sudo virsh net-start "$bridge_name" 1>/dev/null
	fi

	# Obter o pr√≥ximo nome de interface TAP dispon√≠vel
	#tap_name=$(get_next_free_tap)-"$bridge_name"
	tap_name="tap-$bridge_name"

	# Criar a interface TAP (ex: tap0, tap1, tap2...)
	msg_info "$(gettext 'Criando a interface') TAP $tap_name..."
	sudo ip tuntap add dev "$tap_name" mode tap 1>/dev/null

	# Colocar a interface TAP para up
	msg_info "$(gettext 'Ativando a interface') TAP $tap_name..."
	sudo ip link set "$tap_name" up 1>/dev/null

	# Adicionar a interface TAP √† bridge rec√©m-criada
	msg_info "$(gettext 'Adicionando') $tap_name $(gettext '√†') bridge $bridge_name..."
	sudo brctl addif "$bridge_name" "$tap_name" 1>/dev/null

	# Verificar se a bridge e o TAP foram configurados corretamente
	msg_info "$(gettext 'Verificando a associa√ß√£o de interfaces √†') bridge $bridge_name..."
	brctl show "$bridge_name" 1>/dev/null

	# Exibir as interfaces para verificar se tudo est√° funcionando
	msg_info "$(gettext 'Verificando as interfaces de rede...')"
	ip addr show "$bridge_name" 1>/dev/null
	ip addr show "$tap_name" 1>/dev/null

	sudo virsh net-info "$bridge_name"
	msg_info "$(gettext 'Configura√ß√£o conclu√≠da!')"
	exit
}

remove_virbr_bridge_and_tap() {
	local bridge_name="$1"
	local tap_name

	#tap_name="tap$(echo "$bridge_name" | sed 's/[^0-9]*//g')" # Ajuste para pegar o n√∫mero correto do tap
	tap_name="tap-$bridge_name"

	# Remover a bridge
	msg_info "$(gettext 'Removendo') bridge $bridge_name..."
	sudo ip link set "$bridge_name" down 1>/dev/null
	sudo brctl delbr "$bridge_name" 1>/dev/null

	# Remover a interface TAP associada
	if ip link show "$tap_name" &>/dev/null; then
		msg_info "$(gettext 'Removendo') interface TAP $tap_name..."
		sudo ip link set "$tap_name" down 1>/dev/null
		sudo ip tuntap del dev "$tap_name" mode tap 1>/dev/null
	else
		msg_err "$(gettext 'A interface') TAP $tap_name $(gettext 'n√£o existe.')"
	fi

	# Remover a rede do libvirt
	msg_info "$(gettext 'Removendo a rede do') libvirt..."
	sudo virsh net-destroy "$bridge_name" 1>/dev/null
	sudo virsh net-autostart --disable "$bridge_name" 1>/dev/null
	sudo virsh net-undefine "$bridge_name" 1>/dev/null
	sudo ip link delete "$bridge_name" 1>/dev/null
	sudo systemctl restart libvirtd 1>/dev/null

	# Remover a configura√ß√£o da rede do libvirt, caso fique residuos
	local network_config="/etc/libvirt/qemu/networks/${bridge_name}.xml"
	local network_config_autostart="/etc/libvirt/qemu/networks/autostart/${bridge_name}.xml"
	msg_info "$(gettext 'Removendo o arquivo de configura√ß√£o da rede') $bridge_name..."
	sudo rm -fv "$network_config" 1>/dev/null
	sudo rm -fv "$network_config_autostart" 1>/dev/null

	sudo virsh net-info "$bridge_name" 1>/dev/null
	msg_ok "Bridge $bridge_name e TAP $tap_name removidos com sucesso."
	exit 0
}

######################################################################################################

# Fun√ß√£o para obter as interfaces do tipo bridge
get_bridge_interfaces() {
	#  brctl show | awk 'NR > 1 {printf "%s ", $1}'
	#	brctl show | awk 'NR > 1 {printf "%s ", $1}' | sed 's/ $//'
	ip -o link show type bridge | awk -F': ' '{print $2}'
}

list_bridges_detailed() {
	ip -o link show type bridge |
		awk '
   {
     name=$2; sub(":", "", name)
     state=""; mac=""

     # captura STATE e MAC
     for (i=1; i<=NF; i++) {
       if ($i=="state") state=$(i+1)
       if ($i=="link/ether") mac=$(i+1)
     }

     # pegar IP usando getline e analisando "line" (o certo!)
     ip=""
     cmd = "ip -o -4 addr show dev " name " 2>/dev/null"
     while ((cmd | getline line) > 0) {
       split(line, f, " ")
       for (k=1; k<=length(f); k++) {
         if (f[k] == "inet") {
           ip = f[k+1]
         }
       }
     }
     close(cmd)

     printf "  %-20s %-8s %-20s %-18s\n", name, state, mac, ip
   }'
}

# Fun√ß√£o para obter os arquivos RAW no diret√≥rio $HOME_DIR/vdisk/
get_raw_images() {
	local dir="${HOME_DIR:-$HOME}/vdisk"
	# Lista os arquivos com extens√£o .img, removendo o caminho e separando por espa√ßo
	#  find "$dir" -maxdepth 1 -type f -name "*.img" -exec basename {} \; | tr '\n' ' ' | sed 's/ $//'
	find "$dir" -maxdepth 1 -type f \( -name "*.img" -o -name "*.qcow2" \) -exec basename {} \; | tr '\n' ' ' | sed 's/ $//'
}

supports_uefi() {
	fdisk -l "$1" 2>/dev/null | grep -q "EFI"
}

detect_distro() {
	local id=""

	if [[ -r /etc/os-release ]]; then
		# L√™ ID=void|arch|debian|... exatamente como a distro declara
		id=$(grep -E '^ID=' /etc/os-release | cut -d= -f2 | tr -d '"')
	elif [[ -r /usr/lib/os-release ]]; then
		id=$(grep -E '^ID=' /usr/lib/os-release | cut -d= -f2 | tr -d '"')
	else
		echo "unknown"
		return
	fi
	echo "$id"
}

detect_audio_server() {
	if pgrep -x pipewire >/dev/null; then
		echo "pipewire"
	elif pgrep -x pulseaudio >/dev/null; then
		echo "pa"
	elif pgrep -x jackd >/dev/null; then
		echo "jack"
	else
		echo "none"
	fi
}

sh_version() {
	cat <<-EOF
		${bold}${cyan}${0##*/} v${VERSION}${rst}
		${APPDESC}
		${VERSION}
		${bold}${black}Copyright (C) 2019-2025 ChiliLinux Development Team${black}
		${bold}${black}Copyright (C) 2019-2025 Vilmar Catafesta${black}

		  $(gettext 'Este √© um software livre: voc√™ √© livre para alter√°-lo e redistribu√≠-lo.')
		  $(gettext 'O $APP √© disponibilizado para voc√™ sob a ${yellow}Licen√ßa MIT${black}, e')
		  $(gettext 'inclui software de c√≥digo aberto sob uma variedade de outras licen√ßas.')
		  $(gettext 'Voc√™ pode ler instru√ß√µes sobre como baixar e criar para voc√™ mesmo')
		  $(gettext 'o c√≥digo fonte espec√≠fico usado para criar esta c√≥pia.')
		  ${red}$(gettext 'Este programa vem com absolutamente NENHUMA garantia.')
		  ${rst}
	EOF
	exit 0
}

function sh_usage {
	cat <<EOF
$(gettext 'uso:') ${orange}$APP${reset} [$(gettext 'Op√ß√µes')]
${cyan}$(gettext 'Op√ß√µes:')${reset}
  ${rst}-b|--bridge ${orange}<name>                     ${cyan}# $(gettext 'inicia rede em modo') bridge - ex: -b br0 (default: NAT)
  ${rst}-c|--create_real_bridge ${orange}<name>         ${cyan}# $(gettext 'criar real') bridge - ex: -c br0
  ${rst}-r|--remove_real_bridge ${orange}<name>         ${cyan}# $(gettext 'remover real') bridge - ex: -r br0
  ${rst}   --create_virbr_bridge ${orange}<name>        ${cyan}# $(gettext 'criar') virbr bridge - ex: --create_virbr_bridge br0
  ${rst}   --remove_virbr_bridge ${orange}<name>        ${cyan}# $(gettext 'remover') virbr bridge - ex: --remove_virbr_bridge br0
  ${rst}-d|--drive ${orange}<device>                    ${cyan}# $(gettext 'anexa disco externo') - ex: -d /dev/sdX (default: none)
  ${rst}-m|--memory ${orange}<mem>                      ${cyan}# $(gettext 'mem√≥ria inicial de convidado') - ex: -m 16G (default: 8GB)
  ${rst}-v|--vdisk ${orange}<filename.img|qcow2>        ${cyan}# $(gettext 'usa um disco virtual interno') - ( default: none)
  ${rst}   --cvdisk ${orange}<filename>                 ${cyan}# $(gettext 'cria um disco virtual para uso interno')
  ${rst}   --rvdisk ${orange}<filename>                 ${cyan}# $(gettext 'remove um disco virtual')
  ${rst}-g|--video ${orange}<video_driver>              ${cyan}# virtio-vga,virtio-gpu-pci,qxl-vga,VGA,cirrus-vga,ati-vga,virtio-gpu-pci,bochs-display - default: VGA
  ${rst}-N|--network ${orange}<net_driver>              ${cyan}# virtio-net-pci,e1000,rtl8139,vmxnet3 (default: virtio-pc)
  ${rst}-n|--nocolor                           ${cyan}# $(gettext 'remover cores da sa√≠da') - (default: color)
  ${rst}-s|--spice                             ${cyan}# $(gettext 'ativar o') spice - (default: $(gettext 'desligado'))
  ${rst}-t|--tty                               ${cyan}# $(gettext 'ativar modo') tty only - (default: $(gettext 'desligado'))
  ${rst}-l|--list                              ${cyan}# $(gettext 'listar discos virtuais')
  ${rst}-u|--uefi                              ${cyan}# $(gettext 'inicializa√ß√£o em') UEFI - (default: BIOS)
  ${rst}-V|--version                           ${cyan}# $(gettext 'exibe a vers√£o do aplicativo')
  ${rst}-o|--output                            ${cyan}# $(gettext 'exibe a sa√≠da gerada pelo comando e sai')
  ${rst}   --share                             ${cyan}# $(gettext 'compartilha pasta local na VM - (ex: --share /home/user/Imagens)')
  ${rst}-h|-H|--help                           ${cyan}# $(gettext 'imprime este ajuda')
${cyan}$(gettext 'Exemplos:')${rst}
  $ ${orange}$APP${reset} -u -b br0 file.iso          ${cyan}#$(gettext 'Execute uma imagem, em ponte, usando') UEFI ${rst}
  $ ${orange}$APP${reset} -u -s -b br0 file.iso       ${cyan}#$(gettext 'Execute uma imagem, em ponte, usando spice, usando UEFI') ${rst}
  $ ${orange}$APP${reset} -u file.img                 ${cyan}#$(gettext 'Execute uma imagem, em NAT, usando UEFI') ${rst}
  $ ${orange}$APP${reset} -b br0 /dev/sdX             ${cyan}#$(gettext 'Execute uma device, em ponte, usando UEFI') ${rst}
  $ ${orange}$APP${reset} -u -m 16G -b br0 /dev/sdX   ${cyan}#$(gettext 'Execute uma device, em ponte, 16Gb mem√≥ria, usando UEFI') ${rst}
  $ ${orange}$APP${reset} -a pipewire /dev/sdX        ${cyan}#$(gettext 'Execute uma device, em NAT, usando audio pipewire') ${rst}
  $ ${orange}$APP${reset} file.iso                    ${cyan}#$(gettext 'Execute uma imagem usando BIOS')${rst}
  $ ${orange}$APP${reset} -b file.img                 ${cyan}#$(gettext 'Execute uma imagem, em ponte, usando BIOS')${rst}
  $ ${orange}$APP${reset} -m 16G /dev/sdX             ${cyan}#$(gettext 'Execute uma device, 16GB mem√≥ria, usando BIOS') ${rst}
${cyan}$(gettext 'Forma de uso mais comum:')${rst}
  $ ${orange}$APP${reset} filename.iso ${rst}
  $ ${orange}$APP${reset} -u filename.iso ${rst}
  $ ${orange}$APP${reset} /dev/sdX ${rst}
  $ ${orange}$APP${reset} -u /dev/sdX ${rst}
  $ ${orange}$APP${reset} -d /dev/sdX filename.iso ${rst}
  $ ${orange}$APP${reset} -u -d /dev/sdX filename.iso ${rst}
  $ ${orange}$APP${reset} -v vdisk_name.img filename.iso ${rst}
  $ ${orange}$APP${reset} -u -v vdisk_name.img filename.iso ${rst}
  $ ${orange}$APP${reset} $HOME_DIR/vdisk/vdisk_name.img ${rst}
${cyan}$(gettext 'acesso a vm/convidado via ssh:')${rst}
  $ ${rst} ssh live@vsock/555                 ${cyan}# $(gettext 'via') vsock ${rst}
  $ ${rst} ssh live@127.0.0.1 -p 60022        ${cyan}# $(gettext 'via redirecionamento') ${rst}
  $ ${rst} ssh <ip_vm>                        ${cyan}# $(gettext 'via ponte (caso vm iniciada com -b)') ${rst}
  $ ${rst} ssh $USER@127.0.0.1 -p 60022    ${cyan}# $(gettext 'via redirecionamento') ${rst}
EOF
	exit 0
}

sh_createVdiskFiles() {
	local aBlockDisk=(sda.img sdb.img sdc.img sdd.img)
	local aBlockDiskQcow2=(vda.qcow2 vdb.qcow2 vdc.qcow2 vdd.qcow2)
	local file

	if [[ ! -d "$HOME_DIR/vdisk/" ]]; then
		msg_info "$(gettext 'Criando diret√≥rios de trabalho')"
		mkdir -p "$HOME_DIR/vdisk/" &>/dev/null
	fi

	msg_info "$(gettext 'Setando permiss√µes no diret√≥rios de trabalho')"
	sudo chmod 1777 "$HOME_DIR/" &>/dev/null

	for file in "${aBlockDisk[@]}"; do
		if [[ ! -e $HOME_DIR/vdisk/$file ]]; then
			msg_info "$(gettext 'Criando disco virtual') '$file' $(gettext 'no diret√≥rios de trabalho')"
			qemu-img create $HOME_DIR/vdisk/$file -f raw 32G &>/dev/null
		fi
	done
	for file in "${aBlockDiskQcow2[@]}"; do
		if [[ ! -e $HOME_DIR/vdisk/$file ]]; then
			msg_info "$(gettext 'Criando disco virtual') '$file' $(gettext 'no diret√≥rios de trabalho')"
			qemu-img create -f qcow2 $HOME_DIR/vdisk/$file 32G &>/dev/null
		fi
	done
}

sh_setup() {
	local DISTRO=$(detect_distro)
	msg_info "$(gettext 'Instalando necess√°rios pacotes')"

	case "$DISTRO" in
	void)
		msg_ex "$(gettext 'Rodando no') VOID"
		if ! cmd_sudo xbps-install -Sy \
			qemu \
			edk2-ovmf \
			ncurses \
			spice-vdagent \
			virt-viewer \
			python \
			libvirt \
			findutils \
			gawk \
			bridge-utils \
			seabios \
			1>/dev/null 2>&1; then
			die "$(gettext '[ERRO] Falha ao instalar pacotes.')"
		fi
		;;
	chililinux | arch)
		msg_ex "$(gettext 'Rodando no') ${DISTRO^^}"
		cmd_sudo pacman -S --needed --quiet --noconfirm \
			qemu-full \
			edk2-ovmf \
			ncurses \
			spice-vdagent \
			virt-viewer \
			python \
			libvirt \
			findutils \
			gawk \
			bridge-utils \
			seabios 1>/dev/null
		;;
	manjaro) : ;;
	debian) : ;;
	ubuntu) : ;;
	ubuntu) : ;;
	fedora) : ;;
	endeavouros) : ;;
	*)
		echo "$(gettext 'Outra distro:') $DISTRO"
		;;
	esac

	sh_createVdiskFiles
	sh_start_vdagentd "$DISTRO"
}

sh_create_vdisk_file() {
	msg_info "$(gettext 'Criando diret√≥rios de trabalho')"
	mkdir -p "$HOME_DIR/vdisk" &>/dev/null
	msg_info "$(gettext 'Setando permiss√µes no diret√≥rios de trabalho')"
	sudo chmod 1777 "$HOME_DIR/" &>/dev/null
	sudo chown $USER:$USER "$HOME_DIR/" -R &>/dev/null

	while true; do
		sh_list_vdisks
		get 10 10 "$(gettext 'Entre com o nome do disco (sem extens√£o)') - ex vda  : " cvdisk_name
		get 11 10 "$(gettext 'Entre com o tamanho do disco virtual em GB') - ex 32 : " cvdisk_size

		if test -e $HOME_DIR/vdisk/$cvdisk_name.img &>/dev/null; then
			if readconf "$(gettext 'Disco virtual j√° existe, escolha outro nome. Tentar novamente?')"; then
				continue
			fi
		else
			if qemu-img create $HOME_DIR/vdisk/$cvdisk_name.img -f raw "$cvdisk_size"G &>/dev/null; then
				msg_ok "$(gettext 'Disco virtual '$HOME_DIR/vdisk/$cvdisk_name.img' criado com sucesso')"
				echo -n $green
				ls -lh $HOME_DIR/vdisk
				echo -n $rst
				replicate '='
			else
				die "$(gettext 'Falha na cria√ß√£o do disco virtual') $HOME_DIR/vdisk/$cvdisk_name.img"
			fi
		fi
		break
	done
}

sh_list_vdisks() {
	replicate "================== $(gettext 'DISCOS VIRTUAIS DISPON√çVEIS em') $HOME_DIR/vdisk ===================" 1
	echo -n $green
	ls -lh $HOME_DIR/vdisk
	echo -n $rst
	replicate '='
}

sh_remove_vdisk_file() {
	msg_info "$(gettext 'Criando diret√≥rios de trabalho')"
	mkdir -p "$HOME_DIR/vdisk" &>/dev/null
	msg_info "$(gettext 'Setando permiss√µes no diret√≥rios de trabalho')"
	sudo chmod 1777 "$HOME_DIR/" &>/dev/null
	sudo chown $USER:$USER "$HOME_DIR/" -R &>/dev/null

	sh_list_vdisks
	get 10 10 "$(gettext 'Entre com o nome do disco para remover') - ex vda.img : " cvdisk_name

	if test -e $HOME_DIR/vdisk/$cvdisk_name &>/dev/null; then
		if readconf "$(gettext 'PERGUNTA: Deseja realmente excluir o disco virtual ?')"; then
			if rm -f $HOME_DIR/vdisk/$cvdisk_name &>/dev/null; then
				msg_ok "$(gettext 'Disco virtual') '$HOME_DIR/vdisk/$cvdisk_name' $(gettext 'foi removido com sucesso')"
				exit 0
			fi
		fi
		exit $?
	else
		die "$(gettext 'Disco virtual digitado n√£o existe!')"
	fi
}

sh_start_vdagentd() {
	local DISTRO=$(detect_distro)

	if ! pgrep spice-vdagentd; then
		msg_info "$(gettext 'Ativando servi√ßo') spice-vdaagentd $(gettext 'na distro:') ${cyan}${DISTRO^^}"
		case "$DISTRO" in
		void)
			cmd_sudo ln -sf /etc/sv/spice-vdagentd /var/service/ &>/dev/null
			;;
		chililinux | arch)
			cmd_sudo systemctl enable -now spice-vdagentd &>/dev/null
			;;
		*)
			msg_info_tab "$(gettext 'Outra distro:') $DISTRO"
			;;
		esac
	fi
}

# saber se o sistema est√° num TTY puro ou num ambiente gr√°fico
is_graphical() {
	# Wayland ou X11
	[[ "$XDG_SESSION_TYPE" == "x11" || "$XDG_SESSION_TYPE" == "wayland" ]] && return 0
	[[ -n "$DISPLAY" || -n "$WAYLAND_DISPLAY" ]] && return 0
	return 1
}

sh_copyright() {
	echo -n $orange
	echo "$APP - v${VERSION} - ${APPDESC}"
	echo 'Copyright (c) 2019-2025, ChiliLinux Development Team <https://chililinux.com> <https://github.com/chililinux>'
	echo 'Copyright (c) 2019-2025, Vilmar Catafesta <vcatafesta@gmail.com>'
	echo $rst
}

print_avaiable_bridges() {
	local bridges
	#	bridges=($(get_bridge_interfaces))
	mapfile -t bridges < <(list_bridges_detailed)

	echo -e "${cyan}$(gettext 'Pontes dispon√≠veis:')${rst}"
	if [[ ${#bridges[@]} -eq 0 ]]; then
		echo -e "  ${yellow}($(gettext 'nenhuma ponte dispon√≠vel'))${rst}"
	else
		for b in "${bridges[@]}"; do
			echo -e "  ${yellow}${b}${rst}"
		done
	fi
}

add_smb_share() {
	local share_dir="$HOME/share" # opcional, por padr√£o $HOME/share
	local cCmd=''

	# se tiver smbd, cria share e adiciona a op√ß√£o (OBS: smb s√≥ funciona no modo -net user)
	if command -v smbd &>/dev/null; then
		mkdir -p "$share_dir" &>/dev/null
		cCmd=",smb=${share_dir}"
	fi
	echo $cCmd
}

print_summary_access_vm() {
   if $bridge; then
     msg_info "$(gettext 'Parametro') ${yellow}--bridge${rst} $(gettext 'informado. Iniciando VM em modo') ${yellow}BRIDGE${rst} (IP via DHCP)"
   else
     msg_info "$(gettext 'Parametro') ${yellow}--bridge${rst} $(gettext 'n√£o informado. Iniciando VM em modo') ${yellow}NAT${rst} (hostfwd ativo)"
   fi

	msg_info "$(gettext 'acesso a VM via') ${cyan}ssh:"
   msg_info_tab "$(printf "%-45s ${cyan}%s\n" "\$ ssh root@vsock/$GUEST_CID"  "# $(gettext 'via vsock (se habilitado do guest)')")"
   msg_info_tab "$(printf "%-45s ${cyan}%s\n" "\$ ssh $USER@vsock/$GUEST_CID"  "# $(gettext 'via vsock (se habilitado do guest)')")"
   if ! $bridge; then
      msg_info_tab "$(printf "%-45s ${cyan}%s\n" "\$ ssh root@127.0.0.1 -p $HOST_FWD"  "# $(gettext 'via redirecionamento NAT')")"
      msg_info_tab "$(printf "%-45s ${cyan}%s\n" "\$ ssh $USER@127.0.0.1 -p $HOST_FWD"  "# $(gettext 'via redirecionamento NAT')")"
      msg_info_tab "$(printf "%-45s ${cyan}%s\n" "\$ ssh live@127.0.0.1 -p $HOST_FWD"   "# $(gettext 'via redirecionamento NAT')")"
      msg_info_tab "$(printf "%-45s ${cyan}%s\n" "\$ ssh anon@127.0.0.1 -p $HOST_FWD"   "# $(gettext 'via redirecionamento NAT')")"
   else
      bloco_br=$(ip -4 route show dev "$iface_bridge" | awk '$1 ~ "/" {print $1; exit}')
      msg_info_tab "$(printf "%-45s ${cyan}%s\n" "\$ ssh <IP-da-VM>         "     "# $(gettext 'IP atribu√≠do na VM via DHCP') ($bloco_br")"
   fi
}

function sh_start_with_spice() {
	sh_start_vdagentd

	# Informar as portas usadas
	msg_info_tab "SPICE running on port : ${cyan}$random_spice_port${rst}"
	msg_info_tab "$(gettext 'Cliente') SPICE (GUI)   : ${cyan}remote-viewer spice://localhost:$random_spice_port${rst}"

	# Configurar SPICE
	#qemu_options+=(-chardev spicevmc,id=vdagent,debug=0,name=vdagent)
	#qemu_options+=(-device virtserialport,chardev=vdagent,name=com.redhat.spice.0)
	qemu_options+=(
		-spice port=$random_spice_port,disable-ticketing=on
		-monitor tcp:localhost:$random_port,server,nowait
		-chardev spicevmc,id=charchannel0,name=vdagent
		-device virtserialport,chardev=charchannel0,name=com.redhat.spice.0
		-display none
	)

   if $output; then
      cat <<EOF
# ${red}output ${cyan}
sudo env XDG_RUNTIME_DIR=/run/user/\$(id -u) qemu-system-x86_64 ${qemu_options[@]} &
qemu_pid=\$!
remote-viewer spice://localhost:$random_spice_port &
viewer_pid=\$!
wait \$viewer_pid
kill \$qemu_pid &>/dev/null
EOF
      exit 0
   fi
	# Executar o QEMU
	sudo env XDG_RUNTIME_DIR=/run/user/$(id -u) qemu-system-x86_64 "${qemu_options[@]}" &
	qemu_pid=$!
	remote-viewer spice://localhost:$random_spice_port &
	viewer_pid=$!

	# Aguardar o remote-viewer e encerrar o QEMU quando ele fechar
	wait $viewer_pid
	kill $qemu_pid &>/dev/null
}

main() {
	#	local img="$1"
	local params=("$@")
	local img
	local random_port="$(shuf -i 4444-45000 -n 1)"
	local random_spice_port="$(shuf -i 5900-5910 -n 1)"
	local cache_type
	local bootindex
	local media_type
	local count=1
	local devices=()

	# Anexar discos/imagens
	for img in "${params[@]}"; do
		# Verificar se a imagem foi especificada
		[[ -z "$img" ]] && {
			sh_list_vdisks
			die "Erro: vdisk/iso/device #${count} n√£o especificada!"
		}
		if [[ ! -e "$img" ]]; then
			[[ ! -e "$HOME_DIR/vdisk/$img" ]] && {
				log_msg 1 "Check input ${yellow}#${count}: ${cyan}$img"
				sh_list_vdisks
				die "$(gettext 'Erro:') vdisk/iso/device #${count} ${cyan}${img} ${red}$(gettext 'n√£o localizada, tente os listados acima!')${reset}"
			}
			img="$HOME_DIR/vdisk/$img"
		fi
		devices+=("$img")
#		log_msg true "Check input ${yellow}#${count}: ${cyan}$img"

      if (( count == 1 )); then
         log_msg true "Boot source ${yellow}(#${count}): ${cyan}$img"
      else
         log_msg true "Data source ${yellow}(#${count}): ${cyan}$img"
      fi
		((++count))
	done

	# For√ßar UEFI, se solicitado
	if $uefi; then
		sh_checkOVMFFiles
		msg_info "$(gettext 'For√ßando inicializa√ß√£o UEFI...')"
		#[[ ! -e $HOME_DIR/OVMF_VARS.4m.fd ]] && cp -f /usr/share/edk2-ovmf/x64/OVMF_VARS.4m.fd $HOME_DIR/
		cp -f /usr/share/edk2-ovmf/x64/OVMF_VARS.4m.fd $HOME_DIR/
		qemu_options+=(-drive if=pflash,format=raw,readonly=on,file=/usr/share/edk2/x64/OVMF_CODE.4m.fd)
		qemu_options+=(-drive if=pflash,format=raw,file=$HOME_DIR/OVMF_VARS.4m.fd)
	fi

	# Adicionar op√ß√µes padr√£o do QEMU
	qemu_options+=(-no-fd-bootchk)
#	qemu_options+=(-machine accel=kvm)
	qemu_options+=(-cpu host)
	qemu_options+=(-smp "$(nproc)")
	qemu_options+=(-m ${xmem})
	qemu_options+=(-k pt-br)

	#Modo	            Vantagens	                                              Desvantagens
	#cache=none	      Seguro, evita inconsist√™ncias	                          Pode ser mais lento
	#cache=writeback	Boa performance, mant√©m um n√≠vel aceit√°vel de seguran√ßa	Risco de perda de dados em caso de falha
	#cache=directsync	Seguran√ßa m√°xima (grava direto no disco)	              Muito mais lento
	#cache=unsafe	    M√°xima performance	                                    Pode corromper dados se houver falha

	cache_type='writeback'
	bootindex=1 # √çndice de boot inicial

	for img in "${devices[@]}"; do
		media_type=$(file -b --mime-type "${img}")
		#		qemu_options+=(-boot menu=on)
#		if [[ "${media_type}" == "application/x-iso9660-image" ]]; then
      if [[ "$img" == *.iso ]]; then
			msg_info "$(gettext 'Anexando iso') #${bootindex}: ${yellow}${img}"
			qemu_options+=(-drive file="${img}",if=none,id=cdrom${bootindex},media=cdrom)
			qemu_options+=(-device ide-cd,drive=cdrom${bootindex},bootindex=${bootindex})
			((bootindex++))
		elif [[ "${img}" == *.qcow2 ]]; then
			msg_info "$(gettext 'Anexando vdisk') #${bootindex}: ${yellow}${img}"
			qemu_options+=(-drive file="${img}",if=none,id=disk${bootindex},format=qcow2,cache=${cache_type})
			qemu_options+=(-device virtio-blk,drive=disk${bootindex},bootindex=${bootindex})
			((bootindex++))
#		elif [[ "${img}" == /dev/* ]]; then
#			qemu_options+=(-drive file="${img}",if=none,id=disk${bootindex},format=raw,media=disk,cache=${cache_type})
#			qemu_options+=(-device virtio-blk,drive=disk${bootindex},bootindex=${bootindex})
#			msg_info "Anexando device #${bootindex}: ${yellow}${img}"
#			((bootindex++))
      elif [[ -b "$img" ]]; then
         # Disco f√≠sico (block device real):
         # Este bloco trata dispositivos reais em /dev (ex.: /dev/sdX, /dev/nvmeXnY).
         # Diferente dos discos virtuais (arquivos), aqui for√ßamos cache=none e aio=native
         # para evitar qualquer cache duplo no host e reduzir risco de corrup√ß√£o de dados.
         #
         # Essa decis√£o √© intencional e N√ÉO usa cache_type configur√°vel:
         # writeback/unsafe em disco f√≠sico pode causar perda silenciosa de dados
         # em caso de crash do host ou queda de energia.
         #
         # Em resumo:
         # - Disco f√≠sico ‚Üí seguran√ßa e previsibilidade acima de performance
         # - Disco virtual ‚Üí pol√≠tica de cache configur√°vel (ver bloco seguinte)
         # Disco f√≠sico (/dev): usa I/O direto (cache=none,aio=native) para evitar
         # cache duplo e reduzir risco de corrup√ß√£o. Pol√≠tica fixa por seguran√ßa.
         msg_info "$(gettext 'Anexando device') #${bootindex}: ${yellow}${img}"
         qemu_options+=(
            -drive file="${img}",if=none,id=disk${bootindex},format=raw,media=disk,cache=none,aio=native
         )
         qemu_options+=(-device virtio-blk,drive=disk${bootindex},bootindex=${bootindex})
         ((bootindex++))
#		else
#			msg_info "Anexando vdisk #${bootindex}: ${yellow}${img}"
#			#			qemu_options+=(-drive file="${img}",if=none,id=disk${bootindex},format=raw,cache=${cache_type})
#			#			qemu_options+=(-device virtio-blk,drive=disk${bootindex},bootindex=${bootindex})
#			qemu_options+=(-drive file="${img}",if=none,id=disk${bootindex},format=raw)
#			qemu_options+=(-device ahci,id=sata${bootindex})
#			qemu_options+=(-device ide-hd,drive=disk${bootindex},bus=sata${bootindex}.0,bootindex=${bootindex})
#			((bootindex++))
      else
         # Fallback para imagem raw gen√©rica:
         # Este bloco s√≥ √© alcan√ßado quando o arquivo N√ÉO √©:
         #  - ISO (cdrom)
         #  - qcow2 (vdisk gerenciado)
         #  - block device real (disco f√≠sico em /dev)
         #
         # Diferente do bloco anterior (disco f√≠sico), aqui assumimos que o disco
         # √© um ARQUIVO raw comum. Por isso usamos virtio-blk com cache configur√°vel,
         # mantendo bom desempenho sem os riscos de I/O direto no hardware.
         #
         # IDE/AHCI N√ÉO √© usado aqui de prop√≥sito:
         # virtio-blk √© o caminho moderno, mais r√°pido e esperado para sistemas atuais.
         # IDE fica restrito a compatibilidade legada expl√≠cita.
         msg_info "$(gettext 'Anexando vdisk') #${bootindex}: ${yellow}${img} (raw)"
         qemu_options+=(-drive file="${img}",if=none,id=disk${bootindex},format=raw,cache=${cache_type})
         qemu_options+=(-device virtio-blk,drive=disk${bootindex},bootindex=${bootindex})
         ((bootindex++))
		fi
	done

	if $vdisk; then
		for vdsk in "${avdisk_names[@]}"; do
			[[ ! -e "$vdsk" ]] && vdsk="$HOME_DIR/vdisk/$vdsk"
			[[ ! -e "$vdsk" ]] && continue

			if [[ "${vdsk}" == *.img ]]; then
				msg_info "$(gettext 'Anexando vdisk') #${bootindex}: ${yellow}${vdsk}"
				qemu_options+=(-drive file="${vdsk}",if=none,id=disk${bootindex},format=raw,cache=${cache_type})
				qemu_options+=(-device virtio-blk,drive=disk${bootindex},bootindex=${bootindex})
				((bootindex++))
			elif [[ "${vdsk}" == *.qcow2 ]]; then
				msg_info "Anexando vdisk #${bootindex}: ${yellow}${vdsk}"
				qemu_options+=(-drive file="${vdsk}",if=none,id=disk${bootindex},format=qcow2,cache=${cache_type})
				qemu_options+=(-device virtio-blk,drive=disk${bootindex},bootindex=${bootindex})
				((bootindex++))
			fi
		done
	else
		#		msg_warn "Parametro --vdisk n√£o informado, iniciando sem disco virtual..."
		:
	fi

	#	qemu_options+=(-name "chili-fr $*",process=archiso_0)
	qemu_options+=(-name "chili-fr")

	#video
	# CONFIGURA√á√ÉO DE DISPLAY (GTK s√≥ se GUI existir)
	if $only_tty; then
		#/etc/default/grub
		#GRUB_TERMINAL="console"
		#GRUB_GFXPAYLOAD_LINUX=text
		#GRUB_CMDLINE_LINUX="console=tty1 nomodeset"

		# Console interativo no terminal
		qemu_options+=(
			-vga std
			-display curses
		)
	else
#		qemu_options+=(-device virtio-scsi-pci,id=scsi0)
#		qemu_options+=(-audiodev "$(detect_audio_server)",id=snd0)
      audio="${audioserver:-$(detect_audio_server)}"
      qemu_options+=(-audiodev "$audio",id=snd0)
		qemu_options+=(-rtc base=localtime,clock=host)
		qemu_options+=(-device ich9-intel-hda)
#		qemu_options+=(-device hda-output,audiodev=snd0) # s√≥ saida de audio
		qemu_options+=(-device hda-duplex,audiodev=snd0)
		qemu_options+=(-global ICH9-LPC.disable_s3=1)
		qemu_options+=(-machine type=q35,smm=on,accel=kvm,usb=on,pcspk-audiodev=snd0)
		if $lshare; then
         #compartilhamento
         qemu_options+=(-fsdev local,id=fsdev0,path="${cshare}",security_model=passthrough)
         qemu_options+=(-device virtio-9p-pci,fsdev=fsdev0,mount_tag=vmshare)
      fi
      #
      #qemu_options+=(-device intel-iommu)
      #qemu_options+=(-display gtk,gl=on)
	fi

	if $spice; then
      # SPICE video: use QXL. VGA √© fallback; virtio-vga √© para GTK, n√£o SPICE.
#		qemu_options+=(-device qxl)
#		qemu_options+=(-device qxl,heads=1)
#		qemu_options+=(-device qxl,heads=2)
		qemu_options+=(-device "$videodevice")
		qemu_options+=(-device virtio-serial)
		sh_start_with_spice
		exit 0
	else
		qemu_options+=(-device "$videodevice")
#		qemu_options+=(-display gtk,gl=on)
		qemu_options+=(-display sdl)
		if $only_tty; then
		   if $output; then
            cat <<EOF
# ${red}output${cyan}
sudo env SDL_VIDEODRIVER=x11 XDG_RUNTIME_DIR=/run/user/\$(id -u) qemu-system-x86_64 ${qemu_options[@]}
EOF
			   exit 0
	      fi
			cmd_sudo env SDL_VIDEODRIVER=x11 XDG_RUNTIME_DIR=/run/user/$(id -u) qemu-system-x86_64 "${qemu_options[@]}"
			exit 0
		else
		   if $output; then
            cat <<EOF
# ${red}output ${cyan}
sudo env SDL_VIDEODRIVER=x11 XDG_RUNTIME_DIR=/run/user/\$(id -u) qemu-system-x86_64 ${qemu_options[@]}
EOF
   			exit 0
	      fi
			sudo env SDL_VIDEODRIVER=x11 XDG_RUNTIME_DIR=/run/user/$(id -u) qemu-system-x86_64 "${qemu_options[@]}"
			exit 0
		fi
	fi
}
export -f main

params="${@}"
sh_setvarcolors
#sh_copyright

# Display usage information if no arguments are passed
if [[ $# -eq 0 || $1 == @(-h|-H|--help) ]]; then
	sh_usage
fi
if [[ $1 == @(-V|--version) ]]; then
	sh_version
fi

sh_checkDependencies
sh_checkVdiskFiles

OPTIONS=a:m:ub:Vnhd:stg:v:i:N:c:r:l:o:q
LONGOPTIONS=audio:,memory:,uefi,bridge:,version,nocolor,help,drive:,spice,tty,video:,image:,network:,create_virbr_bridge:,remove_virbr_bridge:,create_real_bridge:,remove_real_bridge:,cvdisk,rvdisk,vdisk,list,output,quiet,share:
opts=($(getopt --options="$OPTIONS" --longoptions="$LONGOPTIONS" --name "$0" -- "$@"))
eval set -- "${opts[*]}"

while test ${#opts[*]} -gt 0; do
	case $1 in
	-n | --nocolor)
		sh_unsetvarcolors
		;;
	-u | --uefi)
      msg_info "$(gettext 'Parametro') ${yellow}--uefi${rst} $(gettext 'detectado: usando uefi') ${rst}"

		uefi=true
		;;
	-i | --image)
		if [[ -z "$2" ]]; then
			die "$(gettext 'Argumento inv√°lido para') ${1}, $(gettext 'falta par√¢metro de imagem/disco/device')" >&2
		else
			img="$2"
			shift
		fi
		;;
	-c | --create_real_bridge)
		if [[ -z "$2" ]]; then
			die "$(gettext 'Argumento inv√°lido para') --create_real_bridge. Ex: --create_real_bridge br0"
		else
			create_real_bridge "$2"
			exit 0
		fi
		;;
	-r | --remove_real_bridge)
		if [[ " $(get_bridge_interfaces) " =~ "$2" ]]; then
			bridge_name="$2"
			remove_real_bridge "$bridge_name"
			exit 0
		else
			echo -e "${red}Error:${rst} $(gettext 'Argumento inv√°lido para') ${cyan} ${1} ${rst}" >&2
			print_avaiable_bridges
			exit 1
		fi
		;;
	--create_virbr_bridge)
		if [[ -z "$2" ]]; then
			die "$(gettext 'Argumento inv√°lido para') --create_virbr_bridge, $(gettext 'falta nome para ponte') \nEx.: --create_virbr_bridge br0" >&2
		else
			if [[ " $(get_bridge_interfaces) " =~ "$2" ]]; then
				die "$(gettext 'Argumento inv√°lido para') ${cyan}--create_virbr_bridge${red}. BRIDGE ${cyan}$2 ${red}$(gettext 'j√° existe')" >&2
			else
				bridge_name="$2"
				create_virbr_bridge "$bridge_name"
				shift
			fi
		fi
		;;
	--remove_virbr_bridge)
		if [[ " $(get_bridge_interfaces) " =~ "$2" ]]; then
			bridge_name="$2"
			remove_virbr_bridge_and_tap "$bridge_name"
			shift
		else
			echo -e "${red}Erro:${rst} $(gettext 'Argumento inv√°lido para') ${cyan}${1}${rst}" >&2
			print_avaiable_bridges
			exit 1
		fi
		;;
	-q | --quiet)
	   quiet=true
	   ;;
	-a | --audio)
      next_arg="${2:-}"
      next_arg="${next_arg,,}"
      if [[ "$next_arg" =~ ^(pipewire|pa|jack|none)$ ]]; then
			audioserver="$next_arg"
			msg_info "$(gettext 'Parametro') ${yellow}--audio${rst} $(gettext 'detectado: usando') ${cyan}'$next_arg'${rst}"
			shift
		else
			echo -e "${red}Erro:${rst} $(gettext 'Argumento inv√°lido para') ${cyan}${1}${rst} - v√°lidos: ${yellow}pipewire pa jack none"
			exit 1
		fi
		;;
	-b | --bridge)
		if [[ " $(get_bridge_interfaces) " =~ "$2" ]]; then
			iface_bridge="$2"
			msg_info "$(gettext 'Parametro') ${yellow}--bridge${rst} $(gettext 'detectado: usando ponte') ${cyan}'$iface_bridge'${rst}"
			bridge=true
			shift
		else
			echo -e "${red}Erro:${rst} $(gettext 'Argumento inv√°lido para') ${cyan}${1}${rst}" >&2
			print_avaiable_bridges
			exit 1
		fi
		;;
	--share)
		lshare=true
		cshare="$2"
		msg "$(gettext 'Parametro') ${yellow}--share ${rst}$(gettext 'detectado: usando') ${cyan}${cshare}"
		shift
		;;
	-s | --spice)
		spice=true
		log_msg "$(gettext 'Parametro') ${yellow}--spice ${rst}$(gettext 'detectado: usando spice...')"
		;;
	-t | --tty)
		spice=false
		log_msg "$(gettext 'Parametro') --tty $(gettext 'detectado: ativando') tty only..."
		only_tty=true
		;;
	-g | --video)
		if [[ $2 =~ ^(virtio-vga|virtio-gpu-pci|qxl-vga|VGA|cirrus-vga|ati-vga|virtio-gpu-pci|bochs-display|ramfb)?$ ]]; then
			videodevice="$2"
			shift
		else
			die "$(gettext 'Argumento inv√°lido para') -v. $(gettext 'Use') VGA,virtio-vga,virtio-gpu-pci,qxl-vga,cirrus-vga,ati-vga,virtio-gpu-pci,bochs-display ou ramfb" >&2
		fi
		;;
	-l | --list)
		sh_list_vdisks
		exit 0
		:
		;;
	-v | --vdisk)
		if [[ " $(get_raw_images) " =~ " $2 " || -e "$2" ]]; then
			vdisk_name="$2"
			avdisk_names+=("$vdisk_name")
			vdisk=true
			shift
		else
			sh_list_vdisks
			die "$(gettext 'Argumento inv√°lido para') ${cyan}--vdisk ${rst}$(gettext 'V√°lidos s√£o:') ${yellow}$(get_raw_images)${rst}" >&2
		fi
		;;
	--cvdisk)
		sh_create_vdisk_file
		exit $?
		;;
	--rvdisk)
		sh_remove_vdisk_file
		exit $?
		;;
	-N | --network)
		if [[ $2 =~ ^(virtio-net-pci|e1000|rtl8139|vmxnet3|ne2k_pci|ne2k_isa|pcnet|smc91c111|i82551|i82557b|i82559er)?$ ]]; then
			netdevice="$2"
			anetdevices+=("$netdevice")
			netchoosedriver=true
			msg_info "$(gettext 'Anexando placa de rede'), driver: ${yellow}$netdevice"
			shift
		else
			die "$(gettext 'Argumento inv√°lido para') --network. $(gettext 'Use') virtio-net-pci,e1000,rtl8139,vmxnet3,ne2k_pci,ne2k_isa,pcnet,smc91c111,i82551,i82557b,i82559er" >&2
		fi
		;;
	-o | --output)
	   output=true
	   ;;
	-d | --drive)
		if [[ -n $2 ]]; then
			drive=true
			drive_path=$2
			if lsblk $drive_path &>/dev/null; then
				log_msg "$(gettext 'Parametro') -d,--drive $(gettext 'detectado:') $drive_path"
			else
				die "${cyan}$(gettext 'Parametro') -d,--drive => ${red}$drive_path: $(gettext 'n√£o √© um dispositivo de bloco')"
			fi
			shift
		else
			die "$(gettext 'Argumento inv√°lido para') --drive. $(gettext 'Use formato device, como /dev/sdX (por exemplo).')" >&2
		fi
		;;
	-m | --memory)
		if [[ $2 =~ ^[0-9]+[MGmg]$ ]]; then
			xmem=$2
			log_msg "$(gettext 'Parametro') ${yellow}$1 ${rst}$(gettext 'detectado: Usando') $2"
			shift
		else
			die "$(gettext 'Argumento inv√°lido para') ${yellow}${1}${red}. $(gettext 'Use um formato como 16G (por exemplo).')" >&2
		fi
		;;
	--)
		shift
		break
		;;
	:)
		die "-$OPTARG $(gettext 'requer um argumento')" >&2
		;;
	*)
		die "$(gettext 'opera√ß√£o n√£o suportada:') $1 $(gettext '(usar -h para ajuda')"
		;;
	esac
	shift
done

if [[ $# > 0 ]]; then
	# Configurar rede
	#random_mac_net0=$(python3 -c "import random; print(':'.join(['{:02x}'.format(random.randint(0, 255)) for _ in range(6)]))")
	#random_mac_net1=$(python3 -c "import random; print(':'.join(['{:02x}'.format(random.randint(0, 255)) for _ in range(6)]))")
	#mkdir -p $HOME/share &>/dev/null
	#qemu_options+=(-netdev bridge,id=net0,smb=$HOME)
	#qemu_options+=(-netdev bridge,id=net0)
	#qemu_options+=(-device e1000,netdev=net0)
	#qemu_options+=(-device e1000,netdev=net0,mac=$random_mac_net0)
	#qemu_options+=(-netdev bridge,id=net1,br=$iface_bridge)
	#qemu_options+=(-device e1000,netdev=net1,mac=$random_mac_net1)
	#qemu_options+=(-netdev tap,ifname=tap1,script=no,downscript=no,id=net0)
	#qemu_options+=(-device virtio-net-device,netdev=net0,mac=92:7b:15:c3:4d:ec)

	# intervalo de 555 a 560 ‚Üí tamanho = 560‚àí555+1 = 6
	export GUEST_CID=$((RANDOM % 6 + 555))
#	export HOST_FWD=$((RANDOM % 10000 + 20000))
	export HOST_FWD=$((RANDOM % 6 + 60022))

	if ! $uefi; then
		msg_warn "$(gettext 'Parametro --uefi n√£o informado, usando BIOS legacy (padr√£o)...')"
	fi

	if ! is_graphical; then
		msg_warn "$(gettext 'Nenhum ambiente gr√°fico detectado ‚Äî for√ßando modo TTY.')"
		spice=false
		only_tty=true
	fi

   if $netchoosedriver; then
      for netdevice in "${anetdevices[@]}"; do
         ((nId++))
         netdev_id="net$nId"

         # Verificar o tipo de rede (bridge ou user)
         if $bridge; then
            qemu_options+=(-netdev bridge,id="$netdev_id",br="$iface_bridge")
         else
            # Apenas o primeiro dispositivo recebe hostfwd e smb
            if (( nId == 1 )); then
               qemu_options+=(-netdev user,id="$netdev_id",hostfwd=tcp::$HOST_FWD-:22"$(add_smb_share)")
            else
               qemu_options+=(-netdev user,id="$netdev_id")
            fi
         fi

         # Associar o dispositivo de rede
         qemu_options+=(-device "$netdevice",netdev="$netdev_id")
      done
   else
      netdev_id="net0"
      if $bridge; then
         qemu_options+=(-netdev bridge,id="$netdev_id",br="$iface_bridge")
      else
         qemu_options+=(-netdev user,id="$netdev_id",hostfwd=tcp::$HOST_FWD-:22"$(add_smb_share)")
      fi
      qemu_options+=(-device "$netdevice",netdev="$netdev_id")
   fi

   # Adicionando vhost-vsock
   qemu_options+=(-device vhost-vsock-pci,id=vhost-vsock-pci0,guest-cid="$GUEST_CID")
	print_summary_access_vm

	#windows
#   if ! $spice; then
      # usb-tablet fornece dispositivo de apontamento absoluto.
      # √ötil para GTK/VNC (evita mouse desalinhado).
      # Em SPICE com vdagent ativo, √© desnecess√°rio e pode ser omitido.
   	qemu_options+=(-usb -device usb-tablet)
#   fi

	if $drive; then
		msg_info "$(gettext 'Anexando disco/drive externo:') ${yellow}$drive_path"
		qemu_options+=(-drive file=$drive_path,format=raw,media=disk)
	fi
	main "$@"
else
   log_err "${red}Error${rst}: $(gettext 'Falta par√¢metro de imagem/disco/device.') ${cyan}$(gettext 'Tente os vdisks listados abaixo.') ${yellow}$(gettext '(usar -h para ajuda)')"
	msg_ex_tab "${green}$ ${reset}${APP} ${params} ${rst}vda.img"
	msg_ex_tab "${green}$ ${rst}${APP} ${params} ${rst}/path/filename.img|qcow2|iso|raw"
	msg_ex_tab "${green}$ ${rst}${APP} ${params} ${rst}/dev/sdX"
	msg_ex_tab "${green}$ ${rst}${APP} ${params} ${rst}filename.iso /dev/sdX"
	sh_list_vdisks
   :
fi
